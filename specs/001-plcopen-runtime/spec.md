# Feature Specification: PLCOpen嵌入式运行时环境

**Feature Branch**: `001-plcopen-runtime`
**Created**: 2026-01-18
**Status**: Draft
**Input**: User description: "构建嵌入式程序，一个运行时环境，包含基本的PLCOpen功能块，包括：PID和一阶惯性，未来可扩充更多的功能块，使用C11实现，目标架构是ARM Cortex-M4，开发阶段可使用X86模拟；此运行时支持python脚本，可在python脚本中调用运行时中的PLCOpen功能块，python脚本放在指定的目录位置，可约定命名方式及目录结构，python可添加、修改、或删除，可能有多个python脚本；支持使用VSCode等工具远程调试python脚本;提醒，本机提供了基本的Docker环境;尽量使用国内镜像源，提高依赖包及工具的下载速度."

## Clarifications

### Session 2026-01-18

- Q: 功能块实例共享策略？ → A: 脚本私有，每个脚本创建的功能块实例仅该脚本可见，不同脚本间实例隔离
- Q: Python脚本执行模式？ → A: 主循环周期调用，脚本定义周期性函数，由运行时按固定周期循环调用
- Q: PID算法类型？ → A: 位置式PID，直接输出控制量绝对值
- Q: 脚本热重载行为？ → A: 保留状态，功能块实例状态保留，仅重新加载脚本代码逻辑
- Q: 日志输出目标？ → A: 标准输出+文件，同时输出到控制台和日志文件，文件支持轮转

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 运行PID控制功能块 (Priority: P1)

作为一名控制系统工程师，我需要在Python脚本中调用PID功能块来实现过程控制，以便快速验证控制算法并部署到嵌入式设备。

**Why this priority**: PID是工业控制中最核心和常用的功能块，是整个运行时系统的基础价值体现。

**Independent Test**: 可以通过编写一个简单的Python脚本调用PID功能块，输入设定值和过程值，验证输出控制量是否符合预期。

**Acceptance Scenarios**:

1. **Given** 运行时环境已启动且PID功能块可用，**When** Python脚本创建PID实例并设置Kp=1.0、Ki=0.1、Kd=0.05，**Then** PID实例成功创建并返回有效句柄
2. **Given** PID实例已创建，**When** 脚本调用执行方法传入设定值=100和过程值=80，**Then** 返回合理的控制输出值
3. **Given** PID实例正在运行，**When** 脚本动态修改PID参数，**Then** 新参数立即生效于下一次计算

---

### User Story 2 - 运行一阶惯性功能块 (Priority: P1)

作为一名控制系统工程师，我需要使用一阶惯性（一阶滞后）功能块来模拟或滤波信号，以便实现信号平滑处理和系统仿真。

**Why this priority**: 一阶惯性是基本的信号处理和仿真功能块，与PID同为系统核心功能。

**Independent Test**: 可以通过Python脚本创建一阶惯性实例，输入阶跃信号，验证输出是否呈指数响应曲线。

**Acceptance Scenarios**:

1. **Given** 运行时环境已启动，**When** Python脚本创建一阶惯性实例并设置时间常数T=1.0s和增益K=1.0，**Then** 实例成功创建
2. **Given** 一阶惯性实例已创建，**When** 输入阶跃信号从0变为100，**Then** 输出按照一阶惯性特性逐步趋近100
3. **Given** 一阶惯性实例正在运行，**When** 连续调用执行方法并记录输出，**Then** 输出曲线符合一阶惯性数学模型

---

### User Story 3 - Python脚本热加载管理 (Priority: P2)

作为一名开发人员，我需要能够在运行时添加、修改或删除Python脚本，无需重启整个运行时环境，以便快速迭代和调试控制逻辑。

**Why this priority**: 热加载能力大大提高开发效率，是开发阶段的重要功能。

**Independent Test**: 可以在运行时环境运行期间，向指定目录添加新脚本，验证系统自动识别并加载执行。

**Acceptance Scenarios**:

1. **Given** 运行时环境正在运行，**When** 用户将新的Python脚本放入指定目录，**Then** 系统在下一个扫描周期内检测到并加载该脚本
2. **Given** 某Python脚本正在运行，**When** 用户修改该脚本内容并保存，**Then** 系统检测到变更并重新加载脚本
3. **Given** 某Python脚本正在运行，**When** 用户删除该脚本文件，**Then** 系统停止执行该脚本并释放相关资源

---

### User Story 4 - VSCode远程调试 (Priority: P2)

作为一名开发人员，我需要使用VSCode远程连接到运行时环境调试Python脚本，以便快速定位和修复问题。

**Why this priority**: 调试能力是开发阶段不可或缺的功能，直接影响开发效率。

**Independent Test**: 可以通过VSCode连接到运行中的Docker容器，设置断点，单步执行Python脚本。

**Acceptance Scenarios**:

1. **Given** 运行时环境在Docker容器中运行，**When** 用户在VSCode中配置远程调试并连接，**Then** 成功建立调试会话
2. **Given** 调试会话已建立，**When** 用户在Python脚本中设置断点，**Then** 脚本执行到断点处暂停
3. **Given** 脚本在断点处暂停，**When** 用户查看变量值和调用堆栈，**Then** 显示正确的运行时状态

---

### User Story 5 - X86开发模拟环境 (Priority: P2)

作为一名开发人员，我需要在X86架构的开发机器上运行和测试运行时环境，无需真实的ARM Cortex-M4硬件，以便加速开发周期。

**Why this priority**: 开发阶段不依赖硬件可以大大加速迭代，是开发效率的关键保障。

**Independent Test**: 可以在X86 Docker容器中编译并运行运行时，执行所有功能块测试用例。

**Acceptance Scenarios**:

1. **Given** 开发机器为X86架构，**When** 使用Docker构建开发镜像，**Then** 成功编译X86版本的运行时
2. **Given** X86版本运行时已编译，**When** 启动运行时并执行Python脚本，**Then** 所有功能块行为与ARM目标平台一致
3. **Given** X86开发环境运行正常，**When** 运行功能块单元测试，**Then** 所有测试通过

---

### User Story 6 - 功能块扩展机制 (Priority: P3)

作为一名系统开发人员，我需要能够方便地添加新的PLCOpen功能块到运行时中，以便根据项目需求扩展系统能力。

**Why this priority**: 扩展性是系统长期价值的保障，但初期核心功能更重要。

**Independent Test**: 可以按照既定的接口规范添加新功能块，编译后在Python中调用新功能块。

**Acceptance Scenarios**:

1. **Given** 已有功能块接口规范文档，**When** 开发人员按规范实现新功能块，**Then** 新功能块可被编译到运行时中
2. **Given** 新功能块已编译到运行时，**When** Python脚本尝试调用新功能块，**Then** 能够正常创建实例和执行

---

### Edge Cases

- 当Python脚本存在语法错误时，系统应捕获异常并记录错误日志，不影响其他脚本运行
- 当功能块参数超出有效范围时，系统应返回错误状态并记录日志
- 当脚本目录中存在非Python文件时，系统应忽略这些文件
- 当PID输出超出限幅范围时，系统应自动限幅并提供限幅状态标志
- 当网络中断导致VSCode调试连接断开时，脚本应继续正常运行
- 功能块实例在创建脚本中私有，脚本间无法共享实例，无需处理跨脚本并发访问

## Requirements *(mandatory)*

### Functional Requirements

#### 运行时核心

- **FR-001**: 系统必须提供PID功能块，支持比例、积分、微分控制，并支持参数在线调整
- **FR-002**: 系统必须提供一阶惯性（一阶滞后）功能块，支持时间常数和增益参数配置
- **FR-003**: 系统必须支持功能块实例的创建、执行和销毁生命周期管理
- **FR-004**: 系统必须提供功能块注册机制，允许通过统一接口添加新的功能块类型

#### Python集成

- **FR-005**: 系统必须嵌入Python解释器，允许在Python脚本中调用功能块
- **FR-006**: 系统必须监控指定的脚本目录，支持脚本的添加、修改和删除
- **FR-007**: 系统必须支持多个Python脚本同时运行
- **FR-008**: 系统必须提供Python绑定接口，使脚本能够创建和操作功能块实例
- **FR-009**: 系统必须隔离各脚本的错误，单个脚本异常不影响其他脚本运行

#### 开发与调试

- **FR-010**: 系统必须支持远程调试协议，允许VSCode连接并调试Python脚本
- **FR-011**: 系统必须提供Docker开发环境配置，支持X86架构模拟运行
- **FR-012**: 系统必须提供日志记录功能，记录运行时状态和错误信息
- **FR-013**: 系统必须支持ARM Cortex-M4目标架构的交叉编译

#### 构建与部署

- **FR-014**: 系统必须配置国内镜像源，加速依赖包和工具的下载
- **FR-015**: 系统必须提供Docker Compose配置，简化开发环境的启动和管理

### Key Entities

- **功能块(FunctionBlock)**: 可复用的控制算法单元，包含输入、输出、参数和内部状态，遵循PLCOpen标准接口
- **功能块实例(FunctionBlockInstance)**: 功能块的运行时实例，具有独立的状态和参数，由唯一标识符引用
- **Python脚本(PythonScript)**: 用户编写的控制逻辑脚本，存放于指定目录，可调用功能块实例
- **脚本管理器(ScriptManager)**: 负责监控脚本目录、加载和卸载脚本、管理脚本生命周期
- **运行时环境(Runtime)**: 整体运行时容器，管理功能块库、Python解释器和脚本执行

## Assumptions

- Python脚本目录约定为 `scripts/` 目录，脚本文件扩展名为 `.py`
- 脚本目录扫描周期为1秒（可配置）
- 脚本执行模式为主循环周期调用，脚本需定义 `main()` 函数，由运行时按配置周期（默认100ms）循环调用
- 脚本热重载时保留功能块实例状态，仅重新加载脚本代码逻辑
- PID功能块采用位置式算法（u = Kp*e + Ki*∫e + Kd*de/dt），支持输出限幅
- 一阶惯性功能块采用离散化递推公式实现
- Docker基础镜像使用官方Python镜像并配置国内镜像加速
- 远程调试默认使用debugpy协议，端口5678
- 日志同时输出到标准输出和日志文件，日志文件支持轮转
- ARM交叉编译工具链使用arm-none-eabi-gcc
- 功能块执行周期由调用者控制，运行时不强制周期

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 用户能够在5分钟内完成开发环境搭建并运行第一个示例脚本
- **SC-002**: PID功能块单次执行时间不超过1毫秒（X86开发环境）
- **SC-003**: 一阶惯性功能块计算精度误差不超过0.1%（相对于理论值）
- **SC-004**: 脚本热加载从文件变更到生效时间不超过3秒
- **SC-005**: 系统支持同时运行至少10个独立Python脚本
- **SC-006**: Docker开发环境镜像首次构建时间不超过10分钟（使用国内镜像源）
- **SC-007**: VSCode远程调试连接建立时间不超过5秒
- **SC-008**: 单个功能块实例内存占用不超过1KB
- **SC-009**: 100%的单元测试在X86和ARM目标上通过
