# PIDA功能块技术研究报告

**日期**: 2026-01-20  
**功能**: 带过程值报警的PID控制器 (PIDA)  
**参考源**: IEC61131-1/PIDA/PIDA.xml（ST语言实现）

## 1. 算法核心分析

### 1.1 PID计算方式

**决策**: 采用增量式PID作为基础计算方式  
**理由**: PIDA.xml中使用`du`（增量输出）作为核心计算值，支持两种输出模式
**备选方案**: 位置式PID - 未采用，因为源代码明确使用增量式计算

核心PID公式（标准型 `EQN=0`）：
```
DK = (TD/(KD*cycletime+TD)) * (D1 + KD*(ek-EK_1)/DT1)  // 微分项
du = (ek - EK_1 + cycletime*ek/TI) / DT1               // 比例+积分增量
```

### 1.2 输出模式

**决策**: 支持两种输出模式（OUTOPT控制）  
**理由**: PIDA.xml第870-950行明确定义两种模式

| OUTOPT | 模式 | 公式 |
|--------|------|------|
| 0 | 位置式 | `OUT = uk + OUTCOMP + DK` |
| 1 | 增量式 | `OUT = duout` |

### 1.3 输出补偿方式

**决策**: 支持两种补偿类型（OCTYP控制）  
**理由**: PIDA.xml第950-1000行定义两种补偿计算

| OCTYP | 方式 | 公式 |
|-------|------|------|
| 0 | 加法 | `ukout = uk + OUTCOMP + DK` |
| 1 | 乘法 | `ukout = (uk + DK) * OUTCOMP` |

### 1.4 PID公式类型

**决策**: 支持三种PID公式（EQN控制）  
**理由**: PIDA.xml第930-970行定义三种公式类型

| EQN | 类型 | 微分先行 | 比例先行 |
|-----|------|----------|----------|
| 0 | 标准型 | 否 | 否 |
| 1 | 微分先行 | 是 | 否 |
| 2 | 比例微分先行 | 是 | 是 |

## 2. 运行模式分析

### 2.1 五种运行模式

**决策**: 实现5种运行模式（MODE变量控制）  
**理由**: PIDA.xml VarsData中MODE定义为UINT类型，取值0-4

| MODE | 名称 | 说明 |
|------|------|------|
| 0 | 手动 (MAN) | 操作员手动设置输出 |
| 1 | 自动 (AUTO) | 闭环PID控制 |
| 2 | 串级 (CAS) | 接收上游控制器设定值 |
| 3 | 手动跟踪 (MTRACK) | 手动模式但跟踪外部值 |
| 4 | 自动跟踪 (ATRACK) | 自动模式但跟踪外部值 |

### 2.2 PID回路类型

**决策**: 支持4种PID回路类型（PIDTYPE变量控制）  
**理由**: PIDA.xml第155行定义，影响模式切换和设定值来源

| PIDTYPE | 类型 | 说明 |
|---------|------|------|
| 0 | 单回路 | 独立PID控制 |
| 1 | 串级主调 | 输出作为副调设定值 |
| 2 | 串级副调 | 接收主调输出作为设定值 |
| 3 | 外给定单回路 | 接收外部设定值 |

## 3. 报警系统分析

### 3.1 四级过程值报警

**决策**: 实现4级报警（HH/AH/AL/LL）  
**理由**: PIDA.xml第20-55行定义完整的报警处理逻辑

| 报警 | 变量 | 描述 | 存储位 |
|------|------|------|--------|
| HH | HHIND | 高高限报警 | AM.bit3 |
| AH | AHIND | 高限报警 | AM.bit2 |
| AL | ALIND | 低限报警 | AM.bit1 |
| LL | LLIND | 低低限报警 | AM.bit0 |

### 3.2 报警检测逻辑

**决策**: 使用AI_ALM辅助函数  
**理由**: PIDA.xml使用`AI_ALM(PV,0,0,limit,pre_alarm,db,direction)`函数

检测顺序（重要）：
1. 先检测HH（高高限），若触发则自动设置AH
2. 若HH未触发，检测AH（高限）
3. 若HH和AH均未触发，检测LL（低低限），若触发则自动设置AL
4. 若以上均未触发，检测AL（低限）

### 3.3 偏差报警

**决策**: 独立的偏差报警（DA）  
**理由**: PIDA.xml第1080-1095行定义偏差报警处理

触发条件：`|ek| > DevalmLimit` 且 `DALLV > 0` 且 `ALMOPT = TRUE` 且 `INHDAL = FALSE`

### 3.4 报警切手动

**决策**: 支持报警/故障自动切手动（MANCUT控制）  
**理由**: PIDA.xml第60-75行定义切手动逻辑

MANCUT位定义：
- bit0-bit3: 限值报警切手动控制
- bit8: Q.bit0通道故障切手动
- bit9: Q偶校验故障切手动
- bit10: Q其他故障切手动

## 4. 设定值爬坡分析

### 4.1 爬坡方式

**决策**: 支持两种爬坡方式（RTYP控制）  
**理由**: PIDA.xml第200-400行定义完整的爬坡逻辑

| RTYP | 方式 | 参数 |
|------|------|------|
| 0 | 时间爬坡 | RTIMESP（爬坡时间，分钟） |
| 1 | 速率爬坡 | RRATSP（爬坡速率，工程量/分钟） |

### 4.2 爬坡控制变量

| 变量 | 说明 |
|------|------|
| RCMD | 爬坡启动命令（1=启动） |
| RSPTV | 爬坡目标值 |
| RTIME | 爬坡剩余时间（只读） |
| RRAT | 实际爬坡速率（只读） |
| ROVEP | 输出超限暂停爬坡（1=暂停） |

### 4.3 爬坡暂停机制

**决策**: 支持输出超限时暂停爬坡  
**理由**: PIDA.xml第220行条件判断

暂停条件（ROVEP=1时生效）：
- 输出达到上限(OUT=OUTU)且EK>0且正向爬坡
- 输出达到下限(OUT=OUTL)且EK<0且反向爬坡

## 5. 控制旁路分析

### 5.1 旁路功能

**决策**: 实现控制旁路（CTRBP控制）  
**理由**: PIDA.xml第165-180行定义旁路逻辑

| CTRBP | 状态 | 说明 |
|-------|------|------|
| 0 | 投用 | 正常PID控制 |
| 1 | 旁路 | 跳过PID计算，输出由外部控制 |

### 5.2 旁路约束

- 仅串级副调（PIDTYPE=2）支持旁路
- 仅手动/自动/串级模式（MODE=0/1/2）可切旁路
- 退出旁路自动切手动模式

## 6. 辅助函数分析

### 6.1 需要实现的辅助函数

| 函数 | 原型 | 说明 |
|------|------|------|
| AI_ALM | `int AI_ALM(pv, _, _, limit, pre, db, dir)` | 报警检测 |
| B_GET | `bool B_GET(word, bit)` | 获取位状态 |
| B_WRITE | `word B_WRITE(word, bit, val)` | 设置位状态 |
| GetIECInterval | `dword GetIECInterval(mode)` | 获取扫描周期（毫秒） |

### 6.2 B_GET/B_WRITE实现

**决策**: 使用位操作宏实现  
**理由**: 简单高效，无函数调用开销

```c
#define B_GET(word, bit) (((word) >> (bit)) & 1)
#define B_WRITE(word, bit, val) ((val) ? ((word) | (1 << (bit))) : ((word) & ~(1 << (bit))))
```

### 6.3 AI_ALM实现

**决策**: 独立函数实现报警检测  
**理由**: 逻辑复杂，需要处理死区和方向

```c
// 返回值: 1=报警触发, 0=正常
int ai_alm(float pv, float limit, bool pre_alarm, float deadband, int direction);
// direction: 1=高限检测, 0=低限检测
```

### 6.4 GetIECInterval替代

**决策**: 使用实例参数CYC代替GetIECInterval调用  
**理由**: 
- 原GetIECInterval是PLC系统函数，获取任务扫描周期
- 在Python/C运行时中，周期由调用方控制
- PIDA.xml已将结果存储在CYC变量（秒）

## 7. 数据结构设计

### 7.1 结构体划分

**决策**: 划分为4个结构体  
**理由**: 遵循现有pid.c模式，符合SOLID原则

| 结构体 | 说明 | 变量来源 |
|--------|------|----------|
| pida_params_t | 参数配置 | INPUT中可配置项 |
| pida_input_t | 运行时输入 | INPUT中动态值 |
| pida_state_t | 内部状态 | TEMP变量 |
| pida_output_t | 输出结果 | OUTPUT + INOUT部分 |
| pida_instance_t | 实例容器 | 包含以上四者 |

### 7.2 变量映射原则

- INPUT中Property含"configurable"（值包含4）的 → pida_params_t
- INPUT中其他 → pida_input_t
- OUTPUT全部 → pida_output_t
- INOUT全部 → pida_output_t（可读写）
- TEMP全部 → pida_state_t

## 8. Python绑定设计

### 8.1 API风格

**决策**: 遵循现有py_pid.c的类式API  
**理由**: 保持一致性，符合Python习惯

```python
from plcopen import PIDA

# 创建实例
pida = PIDA(
    kp=100.0,      # 比例带
    ti=10.0,       # 积分时间
    td=0.0,        # 微分时间
    cyc=0.5,       # 扫描周期（秒）
    ...
)

# 执行一步计算
pida.execute(pv=50.0, sp=60.0)

# 读取输出
print(pida.output)
print(pida.hhind, pida.ahind)  # 报警状态
```

### 8.2 属性暴露

**决策**: 只读属性用于输出和状态，可读写用于参数  
**理由**: 防止误操作破坏内部状态

## 9. 测试策略

### 9.1 单元测试覆盖

| 测试类别 | 测试项 |
|----------|--------|
| 参数验证 | KP/TI/TD边界值、限值范围检查 |
| 模式切换 | 5种模式两两切换无扰测试 |
| PID计算 | 3种公式类型、2种输出模式 |
| 报警功能 | 4级限值报警、偏差报警、报警切手动 |
| 爬坡功能 | 时间/速率两种方式、暂停恢复 |
| 旁路功能 | 切入/切出无扰 |

### 9.2 集成测试

- 与现有PID功能块的行为对比
- 串级控制场景（主调+副调）
- 长时间运行稳定性

## 10. 性能考虑

### 10.1 目标

- 单次execute调用 < 100μs
- 内存占用 < 2KB/实例

### 10.2 优化措施

**决策**: 使用内联函数和宏  
**理由**: 减少函数调用开销

- B_GET/B_WRITE使用宏
- CLAMP等常用操作使用现有fb_common.h宏
- 避免浮点数除法（预计算倒数）

## 11. 未解决问题

### 11.1 已确认无需解决

| 问题 | 决策 |
|------|------|
| GetIECInterval系统调用 | 使用CYC参数代替，由调用方传入 |
| Q通道故障位 | 作为输入参数传入，不依赖硬件 |
| AUXOVE/AUXCOMP串级信号 | 通过INPUT变量传入 |

### 11.2 实现时确认

| 问题 | 处理方式 |
|------|----------|
| 浮点比较精度 | 使用PIDA.xml中的1.0E-6阈值 |
| 模式切换无扰 | 严格按照PIDA.xml逻辑实现 |

## 12. 参考资源

1. **PIDA.xml** - 完整ST语言实现（1634行）
2. **H_PIDA.c/h** - 生成的C代码参考
3. **src/fb/pid.c** - 现有PID实现模式
4. **include/plcopen/fb_pid.h** - 头文件结构模式

---

**结论**: 技术研究完成，所有NEEDS CLARIFICATION已解决。可进入Phase 1设计阶段。
