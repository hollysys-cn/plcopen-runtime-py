<?xml version="1.0" encoding="UTF-8"?>
<pou>
	<Path>
		<![CDATA[]]>
	</Path>
	<Name>PIDA</Name>
	<SecondName/>
	<Description>@带过程值报警的PID控制@</Description>
	<PouLogicType>st</PouLogicType>
	<PouType>1</PouType>
	<PouReturnType/>
	<PouData Compiled="0" Lock="0" PouGroup="USER" PaperSize="A4" PrintDirection="0" POUSelfShowName="PIDA">
		<Modifier>_AT</Modifier>
		<ModifyDate>2025-12-09 18:35:52</ModifyDate>
		<STTxt>
			<![CDATA[(*0.报警处理*)
AM:=AM AND 16#0080;
HHIND:=0;AHIND:=0;ALIND:=0;LLIND:=0;
RALALMDB:=(PVU-PVL)*ALMDB*0.01;
IF ALMOPT THEN  (*报警条件中添加工艺报警开关ALMOPT项--sunfengmei*)
	IF (H2>0 AND INHH2=0) THEN(*高高限报警监视*)
		HHIND:=AI_ALM(PV,0,0,HH,PREHH,RALALMDB,1);
		IF HHIND=1 THEN
			AM := B_WRITE(AM,3,TRUE);
			IF (H1>0 AND INHH1=0) THEN
				AHIND:=1;
				AM := B_WRITE(AM,2,TRUE);
			END_IF
		END_IF
	END_IF
	
	IF HHIND=0 AND (PV>=AH-RALALMDB) THEN
		IF (H1>0 AND INHH1=0) THEN (*高限报警监视*)
			AHIND:=AI_ALM(PV,0,0,AH,PREAH,RALALMDB,1);
			IF AHIND=1 THEN
				AM := B_WRITE(AM,2,TRUE);
			END_IF
		END_IF
	END_IF
	
	IF (HHIND=0 AND AHIND=0) AND (L2>0 AND INHL2=0) AND (PV<=LL+RALALMDB) THEN (*低低限报警*)
		LLIND:=AI_ALM(PV,0,0,LL,PRELL,RALALMDB,0);
		IF LLIND=1 THEN
			AM := B_WRITE(AM,0,TRUE);
			IF (L1>0 AND INHL1=0) THEN
				ALIND:=1;
				AM := B_WRITE(AM,1,TRUE);
			END_IF
		END_IF
	END_IF
	
	IF (HHIND=0 AND AHIND=0 AND LLIND=0) AND (L1>0 AND INHL1=0) AND (PV<=AL+RALALMDB) THEN(*低限报警监视*)
		ALIND:=AI_ALM(PV,0,0,AL,PREAL,RALALMDB,0);
		IF ALIND=1 THEN
			AM := B_WRITE(AM,1,TRUE);
		END_IF
	END_IF
ELSE
;
END_IF

PREHH:=HHIND;
PREAH:=AHIND;
PREAL:=ALIND;
PRELL:=LLIND;

(*自动、串级模式时，报警、故障切手动功能*)
IF (MODE=1 OR MODE=2) THEN
	(*限值报警是否切手动*)
	IF NOT(((AM AND MANCUT)AND 16#008F)=16#0000)THEN
		MODE:=0;
	END_IF

	(*Q故障是否切手动*)
	(*2013.11.5 gyj	BASF测试时要求Q.5(偶校验出错)也归做通道故障，受MANCUT.9控制是否切手动*)
	IF NOT((Q AND 16#0020)=16#0000) AND B_GET(MANCUT,9) THEN
		EVENFAULT:=EVENFAULT+1;
	ELSE
		EVENFAULT:=0;
	END_IF
	IF EVENFAULT>2 THEN
		MODE:=0;
	END_IF

	IF (NOT((Q AND 16#0001)=16#0000) AND B_GET(MANCUT,8)) OR (NOT((Q AND 16#0006)=16#0000) AND B_GET(MANCUT,9)) OR (NOT((Q AND 16#0018)=16#0000)AND B_GET(MANCUT,10)) THEN
	MODE:=0;
	END_IF
END_IF
(*1.数据准备*)
lastukout:=OUT;(*上一次的ukout*)
(*//MODIFIED BY DJ，2001/8/11*)
lastduout:=OUT;(*lastduout equal lastukout ,at the means of the rate output and the position output here*)
lastOUT:=OUT;
(*需求OVE改为按位写值：bit0=1表示超上限、bit1=1下限、bit2=0反作用、bit2=1正作用、bit3=0不旁路、bit3=1旁路*)
IF ( (AUXOVE AND 16#08)=16#08 )THEN         (*OVE的bit3位为1表示副回路切旁路*)
	U1:= AUXCOMP;
END_IF;  
uk:=U1;(*用上次的输出值来初始化这次的输出值(没有输出补偿)*)
OVE:=OVE AND 16#F4;(*先将输出超上下限，和初次旁路状态清零*)
IF PVU<=PVL THEN
	PVU:=100;
	PVL:=0; 
END_IF
IF ENGU<=ENGL THEN
	ENGU:=100;
	ENGL:=0;
END_IF
IF OUTU<=OUTL THEN
	OUTU:=100;
	OUTL:=0; 
END_IF
IF OUTU>ENGU THEN
	OUTU:=ENGU;
END_IF
IF OUTL<ENGL THEN
	OUTL:=ENGL;
END_IF
IF (SPU<=SPL) OR (SPU>PVU) OR (SPL<PVL) THEN 
	SPU:=PVU;
	SPL:=PVL; 
END_IF

IF RSPTV>SPU THEN
	RSPTV:=SPU;
END_IF
IF RSPTV<SPL THEN
	RSPTV:=SPL;
END_IF

mu1:=PVU;
md1:=PVL;
IF TI<0 THEN 
	TI:=0;
END_IF
IF KP<=0 THEN
	KP:=100;
END_IF
DT1:=0.01*KP;(*比例带换算*)
DeadInterval:=0.01*ABS(mu1-md1)*DVDB;(*死区*)
DevalmLimit:=0.01*ABS(mu1-md1)*DAL;(*偏差报警限*)
IF PK=0 THEN(*普通PID*)
	SV1:=0.01*ABS(mu1-md1)*INTEDB;(*积分分离值*)
END_IF
IF ((OUTOPT=0) AND(NOT(mu1=md1))AND(NOT(ENGU=ENGL))) THEN
	DT1:=DT1*(mu1-md1)/(ENGU-ENGL);
END_IF
IF KD<=0 THEN(*微分增益不能为零, 防止在线运行时的错误修改,暂时赋值*)
	KD:=1;
END_IF
IF RSPTV>SPU THEN		(*RSPTV爬坡目标值不大于过程输入值上限*)
	RSPTV:=SPU;
END_IF
IF  RSPTV<SPL THEN		(*RSPTV爬坡目标值不小于过程输入值下限*)
	RSPTV:=SPL;
END_IF
IF  RTIMESP<0 THEN		(*RTIME爬坡时间非负*)
	RTIMESP:=0;
END_IF
IF  RRATSP<0 THEN		(*RRATSP设定爬坡速率非负*)
	RRATSP:=0;
END_IF

(*the valid MODE value protect judge as following , to avoid the wrong modified.*)
(*IF ((NOT(MODE=0) )AND  (NOT(MODE=1) )AND  (NOT(MODE=2) )AND  (NOT(MODE=3) )AND(NOT(MODE=4))) THEN*)
(*2011-01-18 高敏 20110118_4 代码走查，因为RM为USINT类型，取值为0~255之间，则实际的RM只有0.1.2.3.4这5个有意义的值，则RM>4的时候就要更改为nowRM，只需判断一次MODE>4就好*)
IF MODE>4 THEN
	MODE:=nowRM;
END_IF

CYC:=DWORD_TO_REAL(GetIECInterval(1))/1000;
IF CYC<=0 THEN
	CYC:=0.5;
END_IF

(*需求：1、当PIDA模式切换到非手动、自动或串级模式时，自动退出控制计算旁路即CTRBP=0；2、手动、自动、串级都可以切旁路 20240311 zhangyl*)
IF (PIDTYPE=2 AND NOT(MODE=0 OR MODE=1 OR MODE=2))  OR (NOT (PIDTYPE=2) )THEN	(*非串级副调或者连锁时，不能切到旁路*)
   CTRBP:=0;
END_IF
IF ((NOT (CTRBP)) AND  preCTRBP=1  AND PIDTYPE=2 AND (MODE=2 AND nowRM=2))  THEN     (*CTRBP退出旁路模式时，切到手动*)
	MODE:=0;
END_IF
IF (CTRBP AND PIDTYPE=2 AND( NOT(MODE=2))AND  nowRM=2 )  THEN     (*MODE从串级切换到手动、自动、连锁时可以退出旁路*)
	CTRBP:=0;
END_IF

IF NOT(MODE=1) THEN
   RCMD:=0;								(*非自动模式下，停止爬坡，即RCMD=0*)
END_IF

IF( MODE <> 0) THEN
	PMSW:=0;			 	(*手动模式下，手动输出源，0=操作面板，1=程序*)   (*原来SW_PMOUT不符合命名规则，将SW_PMOUT改为PMSW    2022.11.28*)
END_IF
              
(*2.副回路自动时，使用内给定值*)
IF PIDTYPE=2 AND (MODE=1 OR MODE=0 OR MODE=3 OR MODE=4) THEN
    (*自动模式下设定值支持爬坡功能*)
    IF MODE=1 THEN				(*MODE:0-手动:1-自动,2-串级,3-手动跟踪,4-自动跟踪*)
        IF RCMD=1 THEN 			(*RCMD=1 爬坡模式*)
            RTYP:= preRTYP;			(*记录上周期值,防止篡改*)
			RSPTV:=preRSPTV;
            IF  RTYP=0 THEN 	(*PTYP爬坡方式0时间方式1速率方式*)
            	RRATSP:=0;  				(*时间爬坡条件下，速率设定值为0*)

				IF RTIMESP <0 OR ABS(RTIMESP) <0.000001 THEN			(* 爬坡时间非负，并排除不用爬坡的情况*) 
                    RTIMESP:=0;
					RRAT:=0;
					RTIME:=0;
					RCMD:=0;
					RCMDFlag:=0;		(*时间爬坡标记，用于判断是否是初次时间爬坡*)
                ELSE
					IF RCMDFlag=0 THEN   (*判断初次爬坡，第一次时RTIME=0 *)
						RRAT:=ABS(RSPTV - INTERSP)/RTIMESP;	(*RRAT爬坡速率，RSPTV爬坡目标值，RTIMESP爬坡设定时间*)
					END_IF
	
					IF (ROVEP=1 AND (((ABS(OUT-OUTU)<0.000001) AND EK>0 AND ((ACTOPT AND (RSPTV > INTERSP)) OR (NOT ACTOPT AND (RSPTV < INTERSP)))) OR ((ABS(OUT-OUTL)<0.000001 )AND EK<0 AND ((ACTOPT AND (RSPTV < INTERSP)) OR (NOT ACTOPT AND (RSPTV > INTERSP)))))) THEN  (*输出超限暂停开关打开，并且输出超上限或者下限*)
						;(*输出超上限或者下限时，爬坡挂起即暂停，等输出值没超限时自动恢复爬坡*)
					ELSE		(*输出值不超限时自动恢复爬坡*)
						IF ( ABS(RSPTV - INTERSP)< RRAT*(CYC/60)	 AND  ( RCMDFlag <> 0)  )  OR ABS(RSPTV - INTERSP)< 0.000001    THEN	(*极小值判断',设定值到达目标值，停止爬坡，爬坡参数重置*)
							INTERSP:=RSPTV;
							RCMD:=0;
							RTIME:=0;
							RTIMESP:=0;
							RRAT:=0;
							RCMDFlag:=0;
						ELSIF(RSPTV > INTERSP) THEN	(*正向爬坡*)
							INTERSP:=INTERSP+RRAT*(CYC/60);	
							IF RRAT< 0  OR ABS(RRAT) <0.000001 THEN
								;
							ELSE	
								RTIME:=(RSPTV - INTERSP)/RRAT;		(*RTIME爬坡倒计时*)	
							END_IF
							RCMDFlag:=1;
							RTIMESP:=preRTIMESP;					(*防止RTIMESP在运行过程中被修改*)	
						ELSE						(*反向爬坡*)
							INTERSP:=INTERSP-RRAT*(CYC/60);
							IF RRAT< 0  OR ABS(RRAT) <0.000001 THEN
								;
							ELSE
								RTIME:=(INTERSP - RSPTV)/RRAT;		(*RTIME爬坡倒计时*)	
							END_IF
							RCMDFlag:=1;
							RTIMESP:=preRTIMESP;					(*防止RTIMESP在运行过程中被修改*)	
						END_IF
					END_IF
				END_IF				
            ELSE							(* RTYP=1 爬坡方式1速率方式*) 
				RTIMESP:=0;					(*速率爬坡条件下，时间设定值为0*)
				IF RRATSP <= 0 THEN			(* 爬坡速率非负*) 
                    RRATSP:=0;
                    RTIME:=0;
					RCMD:=0;
					RRAT:=0;
					RCMDFlag:=0;		(*时间爬坡标记，用于判断是否是初次时间爬坡*)
				ELSE
					RTIME:= ABS(RSPTV-INTERSP)/RRATSP;	(*RTIME爬坡倒计时*)	
					RRAT:=RRATSP;
					IF (ROVEP=1 AND (((ABS(OUT-OUTU)<0.000001) AND EK>0 AND ((ACTOPT AND (RSPTV > INTERSP)) OR (NOT ACTOPT AND (RSPTV < INTERSP)))) OR ((ABS(OUT-OUTL)<0.000001 )AND EK<0 AND ((ACTOPT AND (RSPTV < INTERSP)) OR (NOT ACTOPT AND (RSPTV > INTERSP)))))) THEN  (*输出超限暂停开关打开，并且输出超上限或者下限*)
						;(*输出超上限或者下线时，爬坡挂起即暂停，等输出值没超限时自动恢复爬坡*)
					ELSE		(*输出值不超限时自动恢复爬坡*)	
						IF   (ABS(RSPTV - INTERSP)< RRATSP*(CYC/60)	AND 	RCMDFlag <>0  )   OR ABS(RSPTV - INTERSP)< 0.000001      THEN   	(*极小值判断，除数不等于0，设定值到达目标值，停止爬坡，爬坡参数重置*)	
							INTERSP:=RSPTV; 
							RTIME:=0;
							RCMD:=0;
							RRAT:=0;
							RRATSP:=0;
							RCMDFlag:=0;		(*时间爬坡标记，用于判断是否是初次时间爬坡*)
						ELSIF(RSPTV > INTERSP)THEN	(*正向爬坡*)
							RRATSP:=preRRATSP;								(*防止RRATSP被运行过程中修改*)
							INTERSP:=INTERSP+RRATSP*(CYC/60);	
							RTIME:=RTIME - CYC/60;		(*RTIME爬坡倒计时*)	
							RCMDFlag:=1;		(*时间爬坡标记，用于判断是否是初次时间爬坡*)	
						ELSE						(*反向爬坡*)
							RRATSP:=preRRATSP;								(*防止RRATSP被运行过程中修改*)
							INTERSP:=INTERSP-RRATSP*(CYC/60);		
							RTIME:=RTIME - CYC/60;		(*RTIME爬坡倒计时*)	
							RCMDFlag:=1;		(*时间爬坡标记，用于判断是否是初次时间爬坡*)		
						END_IF	
					END_IF
                END_IF					
            END_IF
	    ELSIF RCMD=0  THEN
              	IF SMANOPT THEN
					CASE SPMODE OF
					1: INTERSP:=INTERSP+SPFRAT;
					2: INTERSP:=INTERSP-SPFRAT;
					3: INTERSP:=INTERSP+SPSRAT;
					4: INTERSP:=INTERSP-SPSRAT;
					END_CASE
	           ELSE
	    	        CASE SPMODE OF
	    		    1: INTERSP:=INTERSP+0.01*SPFRAT*(PVU-PVL);
	    		    2: INTERSP:=INTERSP-0.01*SPFRAT*(PVU-PVL);
	    		    3: INTERSP:=INTERSP+0.01*SPSRAT*(PVU-PVL);
	    		    4: INTERSP:=INTERSP-0.01*SPSRAT*(PVU-PVL);
	    	        END_CASE
	            END_IF
        END_IF
        IF INTERSP>SPU THEN
	        INTERSP:=SPU;
	     END_IF
 	    IF INTERSP<SPL THEN
			INTERSP:=SPL;
	    END_IF
	    SPMODE:=0;
	    sp1:=INTERSP;
	ELSE    (*MODE=0*)
	    IF SMANOPT THEN
		    CASE SPMODE OF
		    	1: INTERSP:=INTERSP+SPFRAT;
		    	2: INTERSP:=INTERSP-SPFRAT;
		    	3: INTERSP:=INTERSP+SPSRAT;
		    	4: INTERSP:=INTERSP-SPSRAT;
		    END_CASE
	    ELSE
		    CASE SPMODE OF
		    	1: INTERSP:=INTERSP+0.01*SPFRAT*(PVU-PVL);
		    	2: INTERSP:=INTERSP-0.01*SPFRAT*(PVU-PVL);
		    	3: INTERSP:=INTERSP+0.01*SPSRAT*(PVU-PVL);
		    	4: INTERSP:=INTERSP-0.01*SPSRAT*(PVU-PVL);
		    END_CASE
	    END_IF
	    IF INTERSP>SPU THEN
	    	INTERSP:=SPU;
	    END_IF
	    IF INTERSP<SPL THEN
	    	INTERSP:=SPL;
	    END_IF
	    SPMODE:=0;
	    sp1:=INTERSP;
	END_IF
ELSE   (*包含以下模式*)   (*包含副回路切串级*)
(*1 PIDTYPE=0*)
(*2 PIDTYPE=1*)
(*3 PIDTYPE=3*)
(*4 PIDTYPE=2 AND MODE=2*)
    (*自动模式下设定值支持爬坡功能*)
    IF MODE=1   THEN    	 
        IF RCMD=1 AND PIDTYPE  <> 3 THEN			 			(* PIDTYPE  <> 3 时的爬坡模式*) 
            RTYP:= preRTYP;						(*防止篡改*)
			RSPTV:=preRSPTV;
            IF  RTYP=0 THEN 				(*PTYP爬坡方式0时间方式1速率方式*)
				RRATSP:=0;  					(*时间模式下，设定爬坡速率值为0*)
				IF RTIMESP <0 OR ABS(RTIMESP) <0.000001  THEN			(* 爬坡时间非负，并排除不用爬坡的情况*) 
                    RTIMESP:=0;
					RRAT:=0;
					RTIME:=0;
					RCMD:=0;
					RCMDFlag:=0;		(*时间爬坡标记，用于判断是否是初次时间爬坡*)
                ELSE
					IF RCMDFlag=0  THEN   (*判断初次爬坡时*)
						RRAT:=ABS(RSPTV - SP)/RTIMESP;	(*RRAT爬坡速率，RSPTV爬坡目标值，RTIMESP爬坡设定时间*)
				(*	ELSE	RRAT:=ABS(RSPTV - SP)/RTIME;     *)
					END_IF

					IF (ROVEP=1 AND (((ABS(OUT-OUTU)<0.000001) AND EK>0 AND ((ACTOPT AND (RSPTV > SP)) OR (NOT ACTOPT AND (RSPTV < SP)))) OR ((ABS(OUT-OUTL)<0.000001 )AND EK<0 AND ((ACTOPT AND (RSPTV < SP)) OR (NOT ACTOPT AND (RSPTV > SP)))))) THEN  (*输出超限暂停开关打开，并且输出超上限或者下限*)
						;(*输出超上限或者下线时，爬坡挂起，等输出值没超限时自动恢复爬坡*)
					ELSE		(*输出值不超限时自动恢复爬坡*)	
						IF   ( ABS(RSPTV - SP)< RRAT*(CYC/60)	  AND  ( RCMDFlag <> 0)  )   OR ABS(RSPTV - SP)< 0.000001  THEN	(*极小值判断，设定值到达目标值，停止爬坡，参数进行重置*)
							SP:=RSPTV;
							RCMD:=0;
							RTIME:=0;			 
							RRAT:=0;
							RTIMESP:=0;
							RCMDFlag:=0;
						ELSIF (RSPTV >  SP)	THEN	(*正向爬坡*)
							SP:=SP+RRAT*(CYC/60);
							IF RRAT< 0  OR ABS(RRAT) <0.000001 THEN
								;
							ELSE		
								RTIME:=(RSPTV - SP)/RRAT;		(*RTIME爬坡倒计时*)	
							END_IF
							RCMDFlag:=1;
							RTIMESP:=preRTIMESP;					(*防止RTIMESP在运行过程中被修改*)	
						ELSE						(*反向爬坡*)
							SP:=SP-RRAT*(CYC/60);
							IF RRAT< 0  OR ABS(RRAT) <0.000001 THEN
								;
							ELSE
								RTIME:=(SP - RSPTV)/RRAT;			(*RTIME爬坡倒计时*)
							END_IF
							RCMDFlag:=1;
							RTIMESP:=preRTIMESP;					(*防止RTIMESP在运行过程中被修改*)	
						END_IF
					END_IF
				END_IF
            ELSE							(* RTYP=1 爬坡方式1速率方式*) 
				RTIMESP:=0;					(*速率爬坡条件下，时间设定值为0*)
				IF RRATSP <= 0 THEN			(* 爬坡速率非负*) 
                    RRATSP:=0;
					RTIME:=0;
					RRAT:=0;
					RCMD:=0;							(* 爬坡速率小于0则推退出爬坡*) 
					RCMDFlag:=0;		(*时间爬坡标记，用于判断是否是初次时间爬坡*)
				ELSE
					RTIME:= ABS(RSPTV-SP)/RRATSP;	(*RTIME爬坡倒计时*)		
					RRAT:=RRATSP;
					IF (ROVEP=1 AND (((ABS(OUT-OUTU)<0.000001) AND EK>0 AND ((ACTOPT AND (RSPTV > SP)) OR (NOT ACTOPT AND (RSPTV < SP)))) OR ((ABS(OUT-OUTL)<0.000001 )AND EK<0 AND ((ACTOPT AND (RSPTV < SP)) OR (NOT ACTOPT AND (RSPTV > SP)))))) THEN  (*输出超限暂停开关打开，并且输出超上限或者下限*)
						;(*输出超上限或者下限时，爬坡挂起即暂停，等输出值没超限时自动恢复爬坡*)
					ELSE		(*输出值不超限时自动恢复爬坡*)	
						IF ( ABS(RSPTV - SP)< (RRATSP*(CYC/60))   AND  	RCMDFlag <> 0  )  OR ABS(RSPTV - SP)< 0.000001    THEN	(*极小值判断，设定值到达目标值，停止爬坡，参数进行重置*)	
							SP:=RSPTV; 
							RTIME:=0;
							RCMD:=0;
							RRAT:=0;
							RRATSP:=0;
							RCMDFlag:=0;		(*时间爬坡标记，用于判断是否是初次时间爬坡*)
						ELSIF (RSPTV > SP)	THEN	(*正向爬坡*)
							RRATSP:=preRRATSP;								(*防止RRATSP在运行过程中被用户修改*)
							SP:=SP+RRATSP*(CYC/60);		
							RTIME:=RTIME-CYC/60;		(*RTIME爬坡倒计时*)	
							RCMDFlag:=1;		(*时间爬坡标记，用于判断是否是初次时间爬坡*)
						ELSE						(*反向爬坡*)
							RRATSP:=preRRATSP;								(*防止RRATSP在运行过程中被用户修改*)
							SP:=SP-RRATSP*(CYC/60);		
							RTIME:=RTIME-CYC/60;		(*RTIME爬坡倒计时*)			
							RCMDFlag:=1;		(*时间爬坡标记，用于判断是否是初次时间爬坡*)
						END_IF				
					END_IF					
                END_IF
            END_IF                  
             
        ELSIF RCMD=0  THEN
            IF SMANOPT THEN
				CASE SPMODE OF
					1: SP:=SP+SPFRAT;
					2: SP:=SP-SPFRAT;
					3: SP:=SP+SPSRAT;
					4: SP:=SP-SPSRAT;
				END_CASE
	        ELSE
				CASE SPMODE OF
					1: SP:=SP+0.01*SPFRAT*(PVU-PVL);
					2: SP:=SP-0.01*SPFRAT*(PVU-PVL);
					3: SP:=SP+0.01*SPSRAT*(PVU-PVL);
					4: SP:=SP-0.01*SPSRAT*(PVU-PVL);
				END_CASE
			END_IF

			IF SP>SPU THEN
				SP:=SPU;
			END_IF
			IF SP<SPL THEN
				SP:=SPL;
			END_IF
		END_IF
 	(*	   SPMODE:=0;			 *)   
   
  	    IF (PIDTYPE=3 AND (MODE=1 )) THEN         (*中安需求，2018.01.29，在单回路外给定  自动情况下，SP只接受来自面板的修改*) 
			IF RCMD=1 THEN	   			(* 爬坡模式*) 
				RTYP:= preRTYP;			(*记录上周期值,防止篡改*)
				RSPTV:=preRSPTV;
				IF  RTYP=0 THEN			(* RTYP=0 时间爬坡方式*) 
					RRATSP:=0;  				(*时间爬坡条件下，速率设定值为0*)
					IF RTIMESP <0 OR ABS(RTIMESP) <0.000001   THEN			(* 爬坡时间非负，并排除不用爬坡的情况*) 
						RTIMESP:=0;
						RRAT:=0;						
						RTIME:=0;
						RCMD:=0;
						RCMDFlag:=0;		(*时间爬坡标记，用于判断是否是初次时间爬坡*)
					ELSE
						IF RCMDFlag=0 THEN   (*判断初次爬坡 *)
							RRAT:=ABS(RSPTV - SP1)/RTIMESP;	(*RRAT爬坡速率，RSPTV爬坡目标值，RTIMESP爬坡设定时间*)
							(*	ELSE	RRAT:=ABS(RSPTV - SP1)/RTIME;     *)
						END_IF

					IF (ROVEP=1 AND (((ABS(OUT-OUTU)<0.000001) AND EK>0 AND ((ACTOPT AND (RSPTV > SP1)) OR (NOT ACTOPT AND (RSPTV < SP1)))) OR ((ABS(OUT-OUTL)<0.000001 )AND EK<0 AND ((ACTOPT AND (RSPTV < SP1)) OR (NOT ACTOPT AND (RSPTV > SP1)))))) THEN  (*输出超限暂停开关打开，并且输出超上限或者下限*)
							;(*输出超上限或者下线时，爬坡挂起即暂停，等输出值没超限时自动恢复爬坡*)
						ELSE		(*输出值不超限时自动恢复爬坡*)						
							IF   (ABS(RSPTV - SP1)< RRAT*(CYC/60)  	 AND  ( RCMDFlag <> 0) )    OR ABS(RSPTV - SP1)< 0.000001  THEN	(*极小值判断，除数不等于0*)
								SP1:=RSPTV;
								RCMD:=0;
								RTIME:=0;
								RTIMESP:=0;
								RRAT:=0;
								RCMDFlag:=0;
							ELSIF (RSPTV > SP1)	THEN (*正向爬坡*)
								SP1:=SP1+RRAT*(CYC/60);	
								IF RRAT< 0  OR ABS(RRAT) <0.000001 THEN
									;
								ELSE
									RTIME:=(RSPTV - SP1)/RRAT;		(*RTIME爬坡倒计时*)
								END_IF
								RCMDFlag:=1;
								RTIMESP:=preRTIMESP;					(*防止RTIMESP在运行过程中被修改*)	
							ELSE					(*反向爬坡*)
								SP1:=SP1-RRAT*(CYC/60);
								IF RRAT< 0  OR ABS(RRAT) <0.000001 THEN
									;
								ELSE
									RTIME:=(SP1 - RSPTV)/RRAT;	(*RTIME爬坡倒计时*)
								END_IF
								RCMDFlag:=1;
								RTIMESP:=preRTIMESP;					(*防止RTIMESP在运行过程中被修改*)	
							END_IF					
						END_IF
					END_IF
				ELSE		(* RTYP=1 速率爬坡方式*) 
					RTIMESP:=0;					(*速率爬坡条件下，时间设定值为0*)
					IF RRATSP <= 0 THEN		(* 爬坡速率非负*) 
						RRATSP:=0;
						RTIME:=0;
						RCMD:=0;
						RRAT:=0;
						RCMDFlag:=0;
					ELSE
						RTIME:= ABS(RSPTV-SP1)/RRATSP;	(*RTIME爬坡倒计时*)	
						RRAT:=RRATSP;				(*更新实际速率*)
					IF (ROVEP=1 AND (((ABS(OUT-OUTU)<0.000001) AND EK>0 AND ((ACTOPT AND (RSPTV > SP1)) OR (NOT ACTOPT AND (RSPTV < SP1)))) OR ((ABS(OUT-OUTL)<0.000001 )AND EK<0 AND ((ACTOPT AND (RSPTV < SP1)) OR (NOT ACTOPT AND (RSPTV > SP1)))))) THEN  (*输出超限暂停开关打开，并且输出超上限或者下限*)
							;(*输出超上限或者下线时，爬坡挂起即暂停，等输出值没超限时自动恢复爬坡*)
						ELSE		(*输出值不超限时自动恢复爬坡*)	
							
							IF (  ABS(RSPTV - SP1)<  ( RRATSP*(CYC/60) )  AND	RCMDFlag  <>0 )   OR ABS(RSPTV - SP1)< 0.000001  THEN   (*极小值判断，设定值到达目标值，停止爬坡，重置爬坡参数*)	
								SP1:=RSPTV; 
								RTIME:=0;
								RCMD:=0;
								RRAT:=0;
								RRATSP:=0;	
								RCMDFlag:=0;						
							ELSIF (RSPTV > SP1)	 THEN	(*正向爬坡*)
								RRATSP:=preRRATSP;								(*防止RRATSP在运行过程中被用户修改*)
								SP1:=SP1+RRATSP*(CYC/60);		
								RTIME:=RTIME-CYC/60;		(*RTIME爬坡倒计时*)	
								RCMDFlag:=1;								
							ELSE						(*反向爬坡*)
								RRATSP:=preRRATSP;								(*防止RRATSP在运行过程中被用户修改*)
								SP1:=SP1-RRATSP*(CYC/60);			
								RTIME:=RTIME-CYC/60;		(*RTIME爬坡倒计时*)	
								RCMDFlag:=1;	
							END_IF										
						END_IF
					END_IF
				END_IF
			ELSIF RCMD=0  THEN
				IF SMANOPT THEN
					CASE SPMODE OF
					1: SP1:=SP1+SPFRAT;
					2: SP1:=SP1-SPFRAT;
					3: SP1:=SP1+SPSRAT;
					4: SP1:=SP1-SPSRAT;
					END_CASE
				ELSE
					CASE SPMODE OF
					1: SP1:=SP1+0.01*SPFRAT*(PVU-PVL);
					2: SP1:=SP1-0.01*SPFRAT*(PVU-PVL);
					3: SP1:=SP1+0.01*SPSRAT*(PVU-PVL);
					4: SP1:=SP1-0.01*SPSRAT*(PVU-PVL);
					END_CASE
				END_IF
				SP1:=MIN(SPU,SP1);
				SP1:=MAX(SPL,SP1);
				SP:=SP1;								
			END_IF
			SPMODE:=0;			
		ELSE
			SP1:=SP; 
			
		END_IF
		SPMODE:=0;						(*SPMODE:SP变化方式:1-快增,2-快减,3-慢增,4-慢减*) 
		
		
    ELSE     (*MODE=0*)
        IF SMANOPT THEN
		    CASE SPMODE OF
		    	1: SP:=SP+SPFRAT;
		    	2: SP:=SP-SPFRAT;
		    	3: SP:=SP+SPSRAT;
		    	4: SP:=SP-SPSRAT;
		    END_CASE
	    ELSE
		    CASE SPMODE OF
		    	1: SP:=SP+0.01*SPFRAT*(PVU-PVL);
		    	2: SP:=SP-0.01*SPFRAT*(PVU-PVL);
		    	3: SP:=SP+0.01*SPSRAT*(PVU-PVL);
		    	4: SP:=SP-0.01*SPSRAT*(PVU-PVL);
		    END_CASE
	    END_IF
	    IF SP>SPU THEN
	    	SP:=SPU;
	    END_IF
	    IF SP<SPL THEN
	    	SP:=SPL;
	    END_IF

		IF (PIDTYPE=3 AND (MODE=0 )) THEN         (*中安需求，2018.01.29，在单回路外给定  自动情况下，SP只接受来自面板的修改*) 
			IF SMANOPT THEN
				CASE SPMODE OF
					1: SP1:=SP1+SPFRAT;
					2: SP1:=SP1-SPFRAT;
					3: SP1:=SP1+SPSRAT;
					4: SP1:=SP1-SPSRAT;
				END_CASE
			ELSE
				CASE SPMODE OF
					1: SP1:=SP1+0.01*SPFRAT*(PVU-PVL);
					2: SP1:=SP1-0.01*SPFRAT*(PVU-PVL);
					3: SP1:=SP1+0.01*SPSRAT*(PVU-PVL);
					4: SP1:=SP1-0.01*SPSRAT*(PVU-PVL);
				END_CASE
			END_IF

			IF SP1>SPU THEN
				SP1:=SPU;
			END_IF
			IF SP1<SPL THEN
				SP1:=SPL;
			END_IF

			SP:=SP1;				
			SPMODE:=0;
		ELSE
			SP1:=SP; 
			
		END_IF
		SPMODE:=0;						(*SPMODE:SP变化方式:1-快增,2-快减,3-慢增,4-慢减*)   
    END_IF    	
END_IF  
 
IF  ( ( RCMDFlag <> 0)     AND   RCMD =0   )  OR     ( ( RCMDFlag <> 0)     AND  ABS( preSP1- SP1 )  < 0.0000001   AND   ROVEP<>1 )  THEN							(*手动切换时 、SP1值不变时    不爬坡的情况*)
	RCMD :=0;
	RTIME:=0;
	RRAT:=0;
	RRATSP:=0;	
	RTIMESP:=0;	
	RCMDFlag:=0;			
END_IF

preRTYP:=RTYP;													(*记录上周期值,防止篡改*)
preRSPTV:=RSPTV;
preRTIMESP:=  RTIMESP;
preRRATSP:=	 RRATSP;									(*记录上周期RRATSP值*)
preSP:=SP;															(*记录上周期SP值*)
preSP1:=SP1;

(*3.副回路切串级后，内给定严格跟踪pc-ic*)
IF PIDTYPE=2 AND MODE=2 THEN
	INTERSP:=sp1;
END_IF
(*GIVERAT 的检查*)
IF GIVERAT<=0 OR GIVERAT>100 THEN
	GIVERAT:=10;
END_IF
IF OUTRAT<=0 OR OUTRAT>100 THEN
	OUTRAT:=5;
END_IF
(*2013.11.10 huyongzhong_修改设定值变化率和输出变化率单位为%/s,同步修改代码*)
RealGiveRat:=GIVERAT*CYC;
RealOutRat:=OUTRAT*CYC;

(*4.设定工作方式，工作方式的切换由界面部分完成*)
IF TRKEN AND TRKSW THEN(*auto track enable AND track switch*)
		IF (NOT (MODE=4)) THEN(*PRM_AUTOTRACK*)
			preRM:=MODE;
			MODE:=4;(*PRM_AUTOTRACK*)
		END_IF
ELSE
	IF (NOT(preRM=4)) THEN(*PRM_AUTOTRACK ) // disable auto track*)
		IF TRKMODE=FALSE THEN	(*2013.11.5 gyj	BASF退出跟踪方式时，工作方式可选，新增TRKMODE项*)
			MODE:=0;
		ELSE
			MODE:=preRM;
		END_IF
		preRM:=4;(*PRM_AUTOTRACK*)
	END_IF
END_IF
(*3.串级主PID的输出处理*) 
(*2002.08.01	串级主PID且串级副PID非串级状态,串级主输出AUXCOMP;  *)    
(*2024.03.1 2串级主PID且串级副PID串级状态并且初次旁路时,串级主这一拍输出AUXCOMP。  ZhangYL*)
IF (PIDTYPE=1 AND( (NOT (AUXMODE=2))  OR   ( AUXMODE=2 AND ((AUXOVE AND 16#08)=8)) ) )THEN  (*PID_CAS*)
	OUT:=AUXCOMP;
	ek:=sp1-PV;
	IF ACTOPT=0 THEN         (*passive action*)
		ek:=-ek-INCOMP;
	ELSE
		ek:=ek+INCOMP;
	END_IF
	IF MODE=0 OR MODE=3 OR MODE=4 THEN
		ek:=sp1-PV;(*for deviation alarm*)
		IF ACTOPT=0 THEN         (*passive action*)
			ek:=-ek-INCOMP;
	    ELSE
		    ek:=ek+INCOMP;
		END_IF
		IF TRKOPT THEN(*已经是串级主调*)
			SP:=PV-INCOMP;(*for setpoint track*)
			SP:=MIN(SPU,SP);
			SP:=MAX(SPL,SP);
		END_IF
	END_IF
	ukout:=AUXCOMP;
    IF OCTYP=0 THEN
        uk:=ukout-OUTCOMP;
    ELSIF OCTYP=1 THEN
		IF OUTCOMP<>0 THEN
			uk:=ukout/OUTCOMP;
		END_IF            
	END_IF
(*4.跟踪模式*)
ELSIF  MODE=3 OR MODE=4 THEN
	IF OUTOPT=1 THEN
		duout:=TRKVAL;                         (*read out Track Point*)	
        duout:=MIN(OUTU,duout);
		duout:=MAX(OUTL,duout);																	                
		OUT:=duout;
            IF OCTYP=0 THEN
                 	du:=duout-OUTCOMP;
            ELSIF OCTYP=1 THEN
                    IF OUTCOMP<>0 THEN
                	    du:=duout/OUTCOMP;
                    END_IF
	        END_IF
	
	ELSE  (*position output*)
		ukout:=TRKVAL;(*read out Track Point*)
		(*modify*)
		ukout:=MIN(OUTU,ukout);
		ukout:=MAX(OUTL,ukout);
		OUT:=ukout;
        IF OCTYP=0 THEN
            uk:=ukout - OUTCOMP;
		ELSIF OCTYP=1 THEN
			IF OUTCOMP<>0  THEN
				uk:=ukout /OUTCOMP;
			END_IF                 
		END_IF		
	END_IF
	ek:=sp1 - PV;(*for deviation alarm *)
	IF ACTOPT=0 THEN         (*passive action*)
		ek:=-ek-INCOMP;
	ELSE
		ek:=ek+INCOMP;
	END_IF
	(*串级副回路跟踪时，考虑内给定值的跟踪*)
	IF (PIDTYPE=2 AND TRKOPT) THEN
		INTERSP:=PV - INCOMP;
		INTERSP:=MIN(SPU,INTERSP);
		INTERSP:=MAX(SPL,INTERSP);
	ELSE
		IF TRKOPT THEN
			SP:=PV-INCOMP;
			SP:=MIN(SPU,SP);
			SP:=MAX(SPL,SP);
		END_IF
	END_IF
(*5.手工调节*)
ELSIF MODE=0 THEN
	RCMD:=0;					(*手动模式 时，RDMD一直置零*)  
	IF PMSW=1 THEN		(*手动模式下，手动输出源，0=操作面板，1=程序*)   (*原来程序SW_PMOUT不符合命名规则，将SW_PMOUT改为PMSW    2022.11.28*)
        IF OUTOPT=1 THEN		(*rate output*) 
        IF(MOLSW) THEN              
			duout:=MIN(OUTU,PMOUT);
			duout:=MAX(OUTL,duout);  
         ELSE
           	duout:=MIN(ENGU,PMOUT);
			duout:=MAX(ENGL,duout);  
          END_IF  	                      			
           OUT:=duout;
           			IF OCTYP=0 THEN
				du:=duout-OUTCOMP;
			ELSIF OCTYP=1 THEN
				IF OUTCOMP<>0  THEN
					du:=duout/OUTCOMP;
				END_IF                    
			END_IF
	    ELSE
       	 IF(MOLSW) THEN 
			ukout:=MIN(OUTU,PMOUT);
			ukout:=MAX(OUTL,ukout);	
          ELSE 
            ukout:=MIN(ENGU,PMOUT);
			ukout:=MAX(ENGL,ukout);
          END_IF	
           	 OUT:=ukout;
			IF OCTYP=0 THEN
				  uk:=ukout-OUTCOMP;
			ELSIF OCTYP=1 THEN
				IF OUTCOMP<>0  THEN
					uk:=ukout/OUTCOMP;
				END_IF                  	   
			END_IF	
        END_IF	                      	    				    	
	ELSE		
	    IF OUTOPT=1 THEN(*rate output*)                          
	        IF OMANOPT THEN
	    		CASE MANMODE OF
	    			1: duout:=MANF;
	    			2: duout:=-MANF;
	    			3: duout:=MANS;
	    			4: duout:=-MANS;
	    		ELSE
	    			duout:=0;
	    		END_CASE;
	    	ELSE
	    		CASE MANMODE OF
	    			1: duout:=0.01*MANF*(ENGU-ENGL);
	    			2: duout:=-0.01*MANF*(ENGU-ENGL);
	    			3: duout:=0.01*MANS*(ENGU-ENGL);
	    			4: duout:=-0.01*MANS*(ENGU-ENGL);
	    		ELSE
	    			duout:=0;
	    		END_CASE;
	    	END_IF
            (*added by gqw*)
            
            IF(MOLSW) THEN              
				duout:=MIN(OUTU,duout);
				duout:=MAX(OUTL,duout);  
         	ELSE
           		duout:=MIN(ENGU,duout);
				duout:=MAX(ENGL,duout);  
          	END_IF   		                      
                OUT:=duout; 
            IF OCTYP=0 THEN
                 du:=duout-OUTCOMP;
            ELSIF OCTYP=1 THEN
                  IF OUTCOMP<>0  THEN
                      du:=duout/OUTCOMP;
                   END_IF                 
	        END_IF	    	
	    ELSE                          (*position output*)
	    	IF OMANOPT THEN
	    		CASE MANMODE OF
	    			1: ukout:=lastukout+MANF;
	    			2: ukout:=lastukout-MANF;
	    			3: ukout:=lastukout+MANS;
	    			4: ukout:=lastukout-MANS;
	    		ELSE
	    			ukout:=lastukout;
	    		END_CASE;
	    	ELSE
	    		CASE MANMODE OF
	    			1: ukout:=lastukout+0.01*MANF*(ENGU-ENGL);
	    			2: ukout:=lastukout-0.01*MANF*(ENGU-ENGL);
	    			3: ukout:=lastukout+0.01*MANS*(ENGU-ENGL);
	    			4: ukout:=lastukout-0.01*MANS*(ENGU-ENGL);
	    		ELSE
	    			ukout:=lastukout;
	    		END_CASE;
	    	END_IF
	    	 IF(MOLSW) THEN 
				ukout:=MIN(OUTU,ukout);
				ukout:=MAX(OUTL,ukout);	
          	ELSE 
            	ukout:=MIN(ENGU,ukout);
				ukout:=MAX(ENGL,ukout);
          	END_IF          
             OUT:=ukout;
            IF OCTYP=0 THEN
                uk:=ukout-OUTCOMP;
            ELSIF OCTYP=1 THEN
				IF OUTCOMP<>0 THEN                       
					uk:=ukout/OUTCOMP;
				END_IF
	        END_IF	    
	    END_IF
		MANMODE:=0;                       (*本周期立即回零*)
	END_IF			
	ek:=sp1-PV;
	IF ACTOPT=0 THEN         (*passive action*)
		ek:=-ek-INCOMP;
	ELSE
	    ek:=ek+INCOMP;
	END_IF
	(*2002.08.01	串级副回路手动时，考虑内给定值的跟踪*)                     
	IF (PIDTYPE=2 AND TRKOPT) THEN
		INTERSP:=PV-INCOMP;
		INTERSP:=MIN(SPU,INTERSP);
		INTERSP:=MAX(SPL,INTERSP);
	ELSE
		IF TRKOPT THEN
			SP:=PV-INCOMP;
			SP:=MIN(SPU,SP);
			SP:=MAX(SPL,SP);
			SP1:=SP; 						  			

			IF (PIDTYPE=3 AND MODE=0) THEN    (*中安需求，2018.01.29，在单回路手动情况下，SP1值跟SP的值，保证手动到自动无扰切换*)
				SP1:=SP;
			END_IF
		END_IF
	END_IF
(*6.自动和串级模式*)
(*如果PIDA是串级副调时，可以旁路副调控制计算，将上一级的PID输出直接输出到副调连接的阀门上。*)
ELSE
	IF  PIDTYPE=2 AND( MODE=2  OR MODE=1  )AND CTRBP=1  AND  preCTRBP=1 THEN           (*自动和串级模式下，串级副调且旁路时，，打了旁路之后的第二拍开始旁路输出*)
		IF ACTOPT THEN				(*ACTOPT=1为反作用*)
	   		 OUT:=(SP-PVL)/(PVU-PVL)*(ENGU-ENGL)+ENGL;
		ELSE 										(*ACTOPT=0为正作用*)
			OUT:=ENGU-(SP-PVL)/(PVU-PVL)*(ENGU-ENGL);
		END_IF
		OUT:=MIN(OUTU,OUT);
		OUT:=MAX(OUTL,OUT);
		RCMD:=0;
        IF (ABS(OUT-lastOUT)>0.01*RealOutRat*(ENGU-ENGL)) THEN
			IF (OUT>lastOUT) THEN
					OUT:=lastOUT+0.01*RealOutRat*(ENGU-ENGL);
			ELSE
					OUT:=lastOUT-0.01*RealOutRat*(ENGU-ENGL);
			END_IF
	    END_IF

		(*real类型不能直接判断等 20221117*)
		IF( OUT>OUTU OR (ABS(OUT-OUTU)<0.000001 ))THEN
			OVE:=OVE AND 16#FD;			(*超下限状态清零*)
    	    OVE:=OVE OR 16#01;			(*写入超上限状态*)
		ELSIF( OUT>OUTU OR (ABS(OUT-OUTL)<0.000001 ))THEN
			OVE:=OVE AND 16#FE;			(*超上限状态清零*)
			OVE:=OVE OR 16#02;			(*写入超下限状态*)
		END_IF
	ELSE	      (*自动和串级模式下，非串级副调旁路时*)		                   
        IF (ABS((sp1-SPCAL)/(PVU-PVL))>RealGiveRat*0.01) THEN
	    	IF(sp1>SPCAL) THEN
	    		SPCAL:=SPCAL+(PVU-PVL)*RealGiveRat*0.01;
	    	ELSE
	    		SPCAL:=SPCAL-(PVU-PVL)*RealGiveRat*0.01;
	    	END_IF
	    ELSE
            SPCAL:=sp1;
        END_IF                        
        ek:=SPCAL-PV;
	    IF ACTOPT=0 THEN         (*passive action*)
	    	ek:=-ek-INCOMP;
	    ELSE
	    	ek:=ek+INCOMP;
	    END_IF                        				
	    cycletime:=CYC;				
	    IF PK=0 THEN         (*normal pid*)
			(*2024.1.17 带微分先行的PID控制      EQN：为PID公式，0=标准型，1=微分先行，2=比例微分先行*)
			 IF  EQN=0  THEN
                     (*DK本周期微分计算值，TD微分时间，D1上周期微分计算值，KD微分增益，ek本周期偏差值，EK_1上周期偏差值，DT1比例带*)
    	    	     DK:=(TD/(KD*cycletime+TD))*(D1+KD*(ek-EK_1)/DT1);
    	            dudd:=DK-D1;
    	            D1:=DK;
            ELSIF  EQN=1  OR   EQN=2   THEN
                    IF ACTOPT=0  THEN
                            DK:=(TD/(KD*cycletime+TD))*(D1+KD*(PV-prePV)/DT1);
                    ELSE
                             DK:=(TD/(KD*cycletime+TD))*(D1+KD*(prePV-PV)/DT1);
                    END_IF
    	            dudd:=DK-D1;
    	            D1:=DK;
            END_IF
            (*2000.12.09   第二次进入死区后，才彻底不运算*)(*OVE按位表示；添加OVE的bit2正反作用，副调节器输出超限添加正反作用的情况*)
			IF ((ABS(ek)<=DeadInterval) AND (DD=1)OR  ((((AUXOVE AND 16#05)=1) AND EK>0) OR (((AUXOVE AND 16#06)=2) AND EK<0 )OR (((AUXOVE AND 16#05)=5) AND EK<0 )OR (((AUXOVE AND 16#06)=6) AND EK>0 )) ) THEN  (*副调节器输出超限*)          
    	    	du:=0;
    	    	DK:=0;     				(*微分分量相关变量（3个）清零*)
    	    	D1:=0;
    	    	dudd:=0;
    	    ELSE                  		(*PID calculate*)
    	    	IF (ABS(ek)<=DeadInterval AND DD=0) THEN
    	    		DD:=1;             	(*第一次进入死区的判断*)
                     
    	    	ELSE
    	    		DD:=0;             	(*未进入死区*)
    	    	END_IF
                     
    	    	IF (ABS(ek)<=SV1) THEN 	(*need Integral*)(*SV1计算积分的分离值*)
    	    		si:=1;
    	    	ELSE                    (*don't need integral*)
    	    		si:=0;
    	    	END_IF
										(*2002.12.31 , move out the old method , think over the TI==0 situation*)
    	    	IF TI=0 OR si=0 THEN		(*不积分的情况：积分时间为0或积分分离*)
					IF  EQN=0  OR  EQN=1  THEN		(*EQN：为PID公式，0=标准型，1=微分先行，2=比例微分先行*)
						du:=(ek-EK_1)/DT1;
					ELSIF  EQN=2  THEN
						IF ACTOPT=0  THEN
							du:=(PV-prePV)/DT1;
						ELSE
							du:=(prePV-PV)/DT1;
						END_IF
                    END_IF
				END_IF
    	    	IF TI<>0 AND si=1 THEN      (*有积分的情况*)
                    IF  EQN=0  OR  EQN=1  THEN      (*EQN：为PID公式，0=标准型，1=微分先行，2=比例微分先行*)
    	    		       du:=(ek-EK_1+cycletime*ek/TI)/DT1;	(*du输出增量值，ek本周期偏差，EK_1上周期偏差值，DT1比例带*)
                     ELSIF  EQN=2  THEN
                           IF ACTOPT=0  THEN
                                  du:=(PV-prePV+cycletime*ek/TI)/DT1;	(*du输出增量值，ek本周期偏差，EK_1上周期偏差值，DT1比例带*)
                           ELSE
                                 du:=(prePV-PV+cycletime*ek/TI)/DT1;
                           END_IF    
                     END_IF    	    		
    	    	END_IF
			(*防止PID在上下限处回调问题处理：1 ek<0&OUT=0时则du:=0；2 ek>0&OUT=100时则du:=0。2024.6.20 , ZhangYL*)
				IF((EK<0 OR ABS(EK)<0.000001) AND ABS(OUT-OUTL)<0.000001 ) THEN
					du:=0;
				END_IF 
				IF((EK>0  OR ABS(EK)<0.000001) AND ABS(OUT-OUTU)<0.000001 )THEN
					du:=0;
				END_IF (*防止PID回调end*)

    	    END_IF
    	END_IF
      (*2002.06.07
     原PID算法的问题在于：不应笼统地对du进行速率限制，应对pi输出进行  速率限制（稳态抗pi超速）、幅值限制（稳态抗pi饱和）,对d分量不进行限制，
     最后对目标输出进行滑动，将微分作用从pid中分离出来，uk du代表仅pi作用 ，DK代表微分作用*)
	    IF (PK=0 OR PK=1) THEN
    	    IF OUTOPT=1 THEN        (*rate output*)
                IF  OCTYP=0 THEN
                    duout:=du+OUTCOMP+DK;
                ELSIF OCTYP=1 THEN
                     duout:=(du+DK)*OUTCOMP;
    	        END_IF
                (*手动输出限幅优化20240926 zyl*)
				(*原算法手动不限幅时手动模式切换为自动或串级模式时PIDA的输出立即被限值在[OUTU,OUTL]范围内*)
                (*优化后当LMBLS=1时OUT值不在[OUTL,OUTU]区间内，从手动切到自动或者串级时，不用立刻限幅到[OUTL,OUTU]区间内，而是要根据正负偏差缓慢降到区间内*)
				IF (nowRM=0 AND LMBLS AND (duout> OUTU OR duout< OUTL) )THEN
					MOFLAG:=TRUE;
				END_IF
				IF (MOFLAG AND LMBLS) THEN
					(*手动非限幅*)  
					IF (((duout > OUTU) AND (duout>lastduout)) OR ((duout < OUTL) AND (duout<lastduout)))THEN
                    	duout:=lastduout;	(*超限时保持上一拍值*)
					END_IF
					IF ((duout<OUTU OR (ABS(duout-OUTU)<1.0E-6)) AND (duout>OUTL OR( ABS(duout-OUTL)<1.0E-6)) )THEN     (*duout∈[OUTL,OUTU]*)
						MOFLAG:=FALSE;
					END_IF
				ELSE 
					(*added by gqw*)
					duout:=MIN(OUTU,duout);
					duout:=MAX(OUTL,duout);
					MOFLAG:=FALSE;
				END_IF	(*手动输出限幅优化end*)
    	    	IF (ABS(duout-lastduout)>0.01*RealOutRat*(ENGU-ENGL)) THEN
    	    		IF (duout>lastduout) THEN
    	    			duout:=lastduout+0.01*RealOutRat*(ENGU-ENGL);
    	    		ELSE
    	    			duout:=lastduout-0.01*RealOutRat*(ENGU-ENGL);
    	    		END_IF
    	    	END_IF
    	    	OUT:=duout;
    	    ELSE                        (*position output*)
          			 (*配合超驰功能块使用*)
					(*20230321修改天津乙烯，现场问题超驰选择，两个PIDA输出同向变化时，超驰块输入项之间不断来回切换的问题*)
					IF (ORSTS AND 16#1)=16#1 THEN      (*PID没有被超驰块选中*)
						IF ((ORSTS AND 16#2)=16#2  AND  EK>0) OR  ((ORSTS AND 16#2)=16#0  AND  EK<0)  THEN    (*下游为高选且EK>0   或  下游为低选且EK<0*)
							U1:=ORFB;
						ELSE
							U1:=ORFB+EK/(PVU-PVL)*100/KP*100;
						END_IF;
					END_IF;
				(***20230321修改天津乙烯END***)
    	    	uk:=U1+du;
                 IF  OCTYP =0 THEN
                 	IF(NOT LMBLS) THEN 	(*pi作用的UK也要考虑手动输出限幅*)
              		 	uk:=MIN(OUTU+(OUTU-OUTL)*(SATDB/100.00)-OUTCOMP,uk);  
    	    		 	uk:=MAX(OUTL-(OUTU-OUTL)*(SATDB/100.00)-OUTCOMP,uk);
                     ELSE
                     	uk:=MIN(ENGU+(ENGU-ENGL)*(SATDB/100.00)-OUTCOMP,uk);	 
    	    		 	uk:=MAX(ENGL-(ENGU-ENGL)*(SATDB/100.00)-OUTCOMP,uk);
                     END_IF	 
    	    	    ukout:=uk+OUTCOMP+DK;
                ELSIF OCTYP=1 THEN
                 	 IF OUTCOMP<>0  THEN
                        IF(NOT LMBLS) THEN 
              		 		uK:=MIN(OUTU+(OUTU-OUTL)*(SATDB/100.00)/OUTCOMP,uk);  
    	    		 		uK:=MAX(OUTL-(OUTU-OUTL)*(SATDB/100.00)/OUTCOMP,uk);
                     	ELSE
                     		uk:=MIN(ENGU+(ENGU-ENGL)*(SATDB/100.00)/OUTCOMP,uk);	 
    	    		 		uk:=MAX(ENGL-(ENGU-ENGL)*(SATDB/100.00)/OUTCOMP,uk);
                     	END_IF	  				
                    END_IF	 
    	    	    ukout:=(uk+DK)*OUTCOMP;
                END_IF						
		    	(*手动输出限幅优化20240926 zyl*)
				(*手动模式切换为自动或串级模式时PIDA的输出立即被限值在[OUTU,OUTL]范围内*)
                (*优化后当LMBLS=1时OUT值不在[OUTL,OUTU]区间内，从手动切到自动或者串级时，不用立刻限幅到[OUTL,OUTU]区间内，而是要根据正负偏差缓慢降到区间内*)
				IF (nowRM=0 AND LMBLS) AND (ukout> OUTU OR ukout< OUTL) THEN
					MOFLAG:=TRUE;
				END_IF
				IF (MOFLAG AND LMBLS) THEN
					(*手动非限幅*)   
				IF ((ukout > OUTU) AND (ukout>lastukout))  OR ((ukout < OUTL) AND (ukout<lastukout)) THEN
					ukout:=lastukout;	(*超限时保持上一拍值*)
				END_IF					
				IF ((ukout<OUTU OR (ABS(ukout-OUTU)<1.0E-6) )AND (ukout>OUTL OR (ABS(ukout-OUTL)<1.0E-6)) )THEN	(*ukout∈[OUTL,OUTU]*)
					MOFLAG:=FALSE;
				END_IF
			ELSE 
				(*added by gqw*)
				ukout:=MIN(OUTU,ukout);
				ukout:=MAX(OUTL,ukout);
				MOFLAG:=FALSE;
			END_IF	(*手动输出限幅优化end*)
    	    	IF (ABS(ukout-lastukout)>0.01*RealOutRat*(ENGU-ENGL)) THEN
    	    		IF (ukout>lastukout) THEN
    	    			ukout:=lastukout+0.01*RealOutRat*(ENGU-ENGL);
    	    		ELSE
    	    			ukout:=lastukout-0.01*RealOutRat*(ENGU-ENGL);
    	    		END_IF
                END_IF

    	    	IF( ukout>OUTU OR (ABS(ukout-OUTU)<0.000001) )THEN
					OVE:=OVE AND 16#FD;			(*超下限状态清零*)
    	    		OVE:=OVE OR 16#01;			(*写入超上限状态*)
    	    	ELSIF( ukout<OUTL OR (ABS(ukout-OUTL)<0.000001 ))THEN
					OVE:=OVE AND 16#FE;
    	    		OVE:=OVE OR 16#02;
    	    	END_IF

    	    	OUT:=ukout;
    		END_IF
    	END_IF
    END_IF
END_IF

IF ((OUT<OUTU OR ABS(OUT-OUTU)<1.0E-6) AND (OUT>OUTL OR ABS(OUT-OUTL)<1.0E-6)) THEN	(*OUTU∈[OUTL,OUTU]*)
	MOFLAG:=FALSE;
END_IF

(*非程控时，程控手动输出值PMOUT与OUT一致，防止切换时输出值跳变。    20230331*)
IF( PMSW <> 1) THEN
	PMOUT:=OUT;			 	(*程控手动模式下输出值跟随输出*)
END_IF

(*偏差报警处理*)
almerror:=ek;
IF NOT(INHDAL) AND DALLV>0 AND ALMOPT THEN(*报警条件中添加工艺报警开关ALMOPT项--sunfengmei*)
	IF ABS(almerror)>DevalmLimit THEN
		DA:=1;
		AM := B_WRITE(AM,7,TRUE);
	ELSE
		DA:=0;
		AM := B_WRITE(AM,7,FALSE);
	END_IF
ELSE
	DA:=0;
	AM := B_WRITE(AM,7,FALSE);
END_IF

MANMODE:=0;(*当三串级模式，在PIDA1手动+PIDA2手动+PIDA3手动，点击PIDA1的手动快增减按钮，此时输出跟踪AUXCOMP,但此时MANMODE已记录到手动快慢增减按钮的值；
切至PIDA1自动+PIDA2串级+PIDA3串级时，PIDA1按照2.2正常手动命令，响应了之前最后一次的增减按钮值修改方法，所以在逻辑运算最后清除指令*)

(*//8.record the result*)


IF (CTRBP=1 )  THEN     (*旁路模式时，需要对U1反推，用于旁路切换时进行无扰输出计算*)
	IF OCTYP=0 THEN	
			U1:=OUT - OUTCOMP;
			I1:=OUT- OUTCOMP;
	ELSE
		IF OUTCOMP<>0  THEN
				U1:=OUT/OUTCOMP;
				I1:=OUT /OUTCOMP;
		ELSE
			U1:=0;				(*0点判断*)
			I1:=0;
		END_IF                 
	END_IF		
ELSE
	U1:=uk;
	I1:=du;
END_IF

EK_2:=EK_1; 
EK_1:=ek;
prePV:=PV;
(*9.output the COMP: especialy for the CAS *)
IF PIDTYPE=2 THEN
	COMP:=INTERSP;
ELSE
	COMP:=PV-INCOMP;
END_IF

IF (CTRBP=1  AND  NOT preCTRBP AND PIDTYPE=2  AND (MODE=2 OR MODE=1 OR MODE=0) )  THEN     (*旁路模式时，需要对U1反推，用于旁路切换时进行无扰输出计算*)
	OVE:=OVE OR 16#08; (*初次切旁路时，将OVE的BIT3置成1*)
	MODE:=2;  (*旁路时，将MODE置2串级模式*)
	IF ACTOPT THEN					(*ACTOPT=1为反作用*)
   		COMP:=(OUT-ENGL)/(ENGU-ENGL)*(PVU-PVL)+PVL;      (*为了旁路无扰，需要将OUT反推后传给主调PIDA的AUXCOMP*)
	ELSE 							(*ACTOPT=0为正作用*)
		COMP:=(ENGU-OUT)/(ENGU-ENGL)*(PVU-PVL)+PVL;      (*为了旁路无扰，需要将OUT反推后传给主调PIDA的AUXCOMP*)
	END_IF
END_IF
preCTRBP:=CTRBP;  
(*需求OVE改为按位写值：bit0=1表示超上限、bit1=1下限、bit2=0反作用、bit2=1正作用、bit3=0不旁路、bit3=1旁路*)
IF (ACTOPT) THEN
	OVE:=OVE AND 16#FB; (*反作用时，将OVE的BIT2置成0*)
ELSE
	OVE:=OVE OR 16#04; (*正作用时，将OVE的BIT2置成1*)
END_IF
nowRM:=MODE;
(*10.modified by DJ, 2001/8/11, set the DK D1 to zero if not AUTO mode*)
IF ((NOT(MODE=1))AND(NOT(MODE=2))) THEN
	DK:=0;
	D1:=0;
END_IF
(*非自动运算，则取消滤波作用*)
IF (NOT((MODE=1)OR(MODE=2))) THEN
	SPCAL:=sp1;
END_IF]]>
		</STTxt>
	</PouData>
	<VarsData>
		<GroupName>PIDA</GroupName>
		<GroupFlag>11</GroupFlag>
		<VarDef Name="PV" OtherName="" Desc="@测量值@" Type="REAL" InitValue="0" Soe="0" Property="197">
			<Data InOutType="INPUT"/>
		</VarDef>
		<VarDef Name="INCOMP" OtherName="" Desc="@输入补偿@" Type="REAL" InitValue="0" Soe="0" Property="37">
			<Data InOutType="INPUT"/>
		</VarDef>
		<VarDef Name="OUTCOMP" OtherName="" Desc="@输出补偿@" Type="REAL" InitValue="0" Soe="0" Property="37">
			<Data InOutType="INPUT"/>
		</VarDef>
		<VarDef Name="TRKVAL" OtherName="" Desc="@跟踪点值@" Type="REAL" InitValue="0" Soe="0" Property="7">
			<Data InOutType="INPUT"/>
		</VarDef>
		<VarDef Name="TRKSW" OtherName="" Desc="@跟踪开关:0-不跟踪,1-跟踪@" Type="BOOL" InitValue="FALSE" Soe="0" Property="7">
			<Data InOutType="INPUT"/>
		</VarDef>
		<VarDef Name="PIDTYPE" OtherName="" Desc="@PID回路类型:0-单回路,1-串级主调,2-串级副调@" Type="UINT" InitValue="0" Soe="0" Property="37">
			<Data InOutType="INPUT"/>
		</VarDef>
		<VarDef Name="AUXMODE" OtherName="" Desc='@副调运行方式,请赋值为"副调点名.MODE"@' Type="UINT" InitValue="0" Soe="0" Property="5">
			<Data InOutType="INPUT"/>
		</VarDef>
		<VarDef Name="AUXCOMP" OtherName="" Desc='@副调PV-INCOMP,请赋值为"副调点名.COMP"@' Type="REAL" InitValue="0" Soe="0" Property="5">
			<Data InOutType="INPUT"/>
		</VarDef>
		<VarDef Name="AUXOVE" OtherName="" Desc='@副调节器输出是否超限,请赋值为"副调点名.OVE"@' Type="BYTE" InitValue="0" Soe="0" Property="1">
			<Data InOutType="INPUT"/>
		</VarDef>
		<VarDef Name="TD" OtherName="" Desc="@微分时间@" Type="REAL" InitValue="0" Soe="0" Property="4133">
			<Data InOutType="INPUT"/>
		</VarDef>
		<VarDef Name="Q" OtherName="" Desc="@测量值质量@" Type="WORD" InitValue="0" Soe="0" Property="69">
			<Data InOutType="INPUT"/>
		</VarDef>
		<VarDef Name="ALMOPT" OtherName="" Desc="@过程报警开关 0-关 1-开@" Type="BOOL" InitValue="TRUE" Soe="0" Property="37">
			<Data InOutType="INPUT"/>
		</VarDef>
		<VarDef Name="ORSTS" OtherName="" Desc="@超驰反馈输入状态@" Type="BYTE" InitValue="0" Soe="0" Property="7">
			<Data InOutType="INPUT"/>
		</VarDef>
		<VarDef Name="ORFB" OtherName="" Desc="@超驰反馈输入值@" Type="REAL" InitValue="0" Soe="0" Property="7">
			<Data InOutType="INPUT"/>
		</VarDef>
		<VarDef Name="LOCK" OtherName="" Desc="@是否锁定操作面板@" Type="BOOL" InitValue="FALSE" Soe="0" Property="1">
			<Data InOutType="INPUT"/>
		</VarDef>
		<VarDef Name="DEV_OWNER" OtherName="" Desc="@占用ID@" Type="STRING" InitValue="" Soe="0" Property="1">
			<Data InOutType="INPUT" Capacity="64"/>
		</VarDef>
		<VarDef Name="OUT" OtherName="" Desc="@输出值@" Type="REAL" InitValue="0" Soe="0" Property="8390">
			<Data InOutType="OUTPUT"/>
		</VarDef>
		<VarDef Name="SP" OtherName="" Desc="@设定值@" Type="REAL" InitValue="0" Soe="0" Property="8388">
			<Data InOutType="INOUT"/>
		</VarDef>
		<VarDef Name="CYC" OtherName="" Desc="@计算周期(秒)@" Type="REAL" InitValue="0.5" Soe="0" Property="4">
			<Data InOutType="INOUT"/>
		</VarDef>
		<VarDef Name="MODE" OtherName="" Desc="@运行模式:0-手动:1-自动,2-串级,3-手动跟踪,4-自动跟踪@" Type="UINT" InitValue="0" Soe="0" Property="8196">
			<Data InOutType="INOUT"/>
		</VarDef>
		<VarDef Name="KP" OtherName="" Desc="@比例带, 百分数(%)@" Type="REAL" InitValue="100" Soe="0" Property="4132">
			<Data InOutType="INOUT"/>
		</VarDef>
		<VarDef Name="TI" OtherName="" Desc="@积分时间@" Type="REAL" InitValue="30" Soe="0" Property="4132">
			<Data InOutType="INOUT"/>
		</VarDef>
		<VarDef Name="KD" OtherName="" Desc="@微分增益@" Type="REAL" InitValue="1" Soe="0" Property="4132">
			<Data InOutType="INOUT"/>
		</VarDef>
		<VarDef Name="OUTU" OtherName="" Desc="@输出上限值@" Type="REAL" InitValue="100" Soe="0" Property="36">
			<Data InOutType="INOUT"/>
		</VarDef>
		<VarDef Name="OUTL" OtherName="" Desc="@输出下限值@" Type="REAL" InitValue="0" Soe="0" Property="36">
			<Data InOutType="INOUT"/>
		</VarDef>
		<VarDef Name="RTIMESP" OtherName="" Desc="@爬坡时间设定，单位：min@" Type="REAL" InitValue="0" Soe="0" Property="4">
			<Data InOutType="INOUT"/>
		</VarDef>
		<VarDef Name="RRATSP" OtherName="" Desc="@爬坡速率设定，单位：工程量/min@" Type="REAL" InitValue="0" Soe="0" Property="4">
			<Data InOutType="INOUT"/>
		</VarDef>
		<VarDef Name="RCMD" OtherName="" Desc="@爬坡命令，0=停止，1=启动@" Type="BYTE" InitValue="0" Soe="0" Property="4">
			<Data InOutType="INOUT"/>
		</VarDef>
		<VarDef Name="RSPTV" OtherName="" Desc="@爬坡目标值，单位和量程同SP@" Type="REAL" InitValue="0" Soe="0" Property="4">
			<Data InOutType="INOUT"/>
		</VarDef>
		<VarDef Name="PMSW" OtherName="" Desc="@手动输出源，0=人工操作，1=程序控制@" Type="BOOL" InitValue="FALSE" Soe="0" Property="6">
			<Data InOutType="INOUT"/>
		</VarDef>
		<VarDef Name="PMOUT" OtherName="" Desc="@手动模式下的输出值@" Type="REAL" InitValue="0" Soe="0" Property="6">
			<Data InOutType="INOUT"/>
		</VarDef>
		<VarDef Name="ENGU" OtherName="" Desc="@输出量程上限@" Type="REAL" InitValue="100" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="ENGL" OtherName="" Desc="@输出量程下限@" Type="REAL" InitValue="0" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="PVU" OtherName="" Desc="@PV量程上限@" Type="REAL" InitValue="100" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="PVL" OtherName="" Desc="@PV量程下限@" Type="REAL" InitValue="0" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="INTEDB" OtherName="" Desc="@积分分离值/反向限(%)@" Type="REAL" InitValue="100" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="DAL" OtherName="" Desc="@偏差报警限,百分数(%)@" Type="REAL" InitValue="30" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="DVDB" OtherName="" Desc="@输入死区/全开关限@" Type="REAL" InitValue="0.2" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="OUTRAT" OtherName="" Desc="@输出变化率,单位%/s@" Type="REAL" InitValue="5" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="GIVERAT" OtherName="" Desc="@SP变化率,单位%/s@" Type="REAL" InitValue="10" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="MANF" OtherName="" Desc="@手动输出快速变化率（量）@" Type="REAL" InitValue="1.5" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="MANS" OtherName="" Desc="@手动输出慢速变化率（量）@" Type="REAL" InitValue="0.5" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="SPFRAT" OtherName="" Desc="@SP快速变化率（量）@" Type="REAL" InitValue="5" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="SPSRAT" OtherName="" Desc="@SP慢速变化率（量）@" Type="REAL" InitValue="1" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="L2" OtherName="" Desc="@低低限报警级@" Type="BYTE" InitValue="0" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="L1" OtherName="" Desc="@低限报警级@" Type="BYTE" InitValue="0" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="H1" OtherName="" Desc="@高限报警级@" Type="BYTE" InitValue="0" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="H2" OtherName="" Desc="@高高限报警级@" Type="BYTE" InitValue="0" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="LL" OtherName="" Desc="@报警低低限@" Type="REAL" InitValue="0" Soe="0" Property="4196">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="AL" OtherName="" Desc="@报警低限@" Type="REAL" InitValue="0" Soe="0" Property="4196">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="AH" OtherName="" Desc="@报警高限@" Type="REAL" InitValue="0" Soe="0" Property="4196">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="HH" OtherName="" Desc="@报警高高限@" Type="REAL" InitValue="0" Soe="0" Property="4196">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="ALMDB" OtherName="" Desc="@限值报警死区@" Type="REAL" InitValue="2" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="INHH2" OtherName="" Desc="@高高限报警抑制@" Type="BOOL" InitValue="FALSE" Soe="0" Property="36">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="INHH1" OtherName="" Desc="@高限报警抑制@" Type="BOOL" InitValue="FALSE" Soe="0" Property="36">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="INHL1" OtherName="" Desc="@低限报警抑制@" Type="BOOL" InitValue="FALSE" Soe="0" Property="36">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="INHL2" OtherName="" Desc="@低低限报警抑制@" Type="BOOL" InitValue="FALSE" Soe="0" Property="36">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="DALLV" OtherName="" Desc="@偏差报警级@" Type="BYTE" InitValue="0" Soe="0" Property="96">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="INHDAL" OtherName="" Desc="@偏差报警抑制:0-不抑制,1-抑制@" Type="BOOL" InitValue="FALSE" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="OUTOPT" OtherName="" Desc="@输出方式:0-位置式,1-增量式@" Type="BOOL" InitValue="FALSE" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="ACTOPT" OtherName="" Desc="@作用方式:0-正作用,1-反作用@" Type="BOOL" InitValue="TRUE" Soe="0" Property="4196">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="TRKOPT" OtherName="" Desc="@SP跟踪PV:0-SP不跟踪PV,1-SP跟踪PV@" Type="BOOL" InitValue="TRUE" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="MANMODE" OtherName="" Desc="@手动输出模式:1-快增,2-快减,3-慢增,4-慢减@" Type="BYTE" InitValue="0" Soe="0" Property="4">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="TRKEN" OtherName="" Desc="@跟踪允许:0-不允许跟踪,1-允许跟踪@" Type="BOOL" InitValue="TRUE" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="MANCUT" OtherName="" Desc="@测量值报警是否切(需按位设置):0-不切手动,1-切手动@" Type="WORD" InitValue="1920" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="PK" OtherName="" Desc="@PID 类型:0-普通,1-智能@" Type="BYTE" InitValue="0" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="OMANOPT" OtherName="" Desc="@手动输出单步变化方式:0-百分比,1-工程量@" Type="BOOL" InitValue="FALSE" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="SPMODE" OtherName="" Desc="@SP变化方式:1-快增,2-快减,3-慢增,4-慢减@" Type="BYTE" InitValue="0" Soe="0" Property="36">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="SMANOPT" OtherName="" Desc="@SP单步变化方式:0-百分比,1-工程量@" Type="BOOL" InitValue="FALSE" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="INTERSP" OtherName="" Desc="@内给定值@" Type="REAL" InitValue="0" Soe="0" Property="8196">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="TRKMODE" OtherName="" Desc="@退出跟踪后模式选择:0-回到手动方式,1-回到跟踪前的工作状态@" Type="BOOL" InitValue="FALSE" Soe="0" Property="4132">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="PREHH" OtherName="" Desc="@用户不可写——上周期高高限报警@" Type="BOOL" InitValue="FALSE" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="PREAH" OtherName="" Desc="@用户不可写——上周期高限报警@" Type="BOOL" InitValue="FALSE" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="PREAL" OtherName="" Desc="@用户不可写——上周期低限报警@" Type="BOOL" InitValue="FALSE" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="PRELL" OtherName="" Desc="@用户不可写——上周期低低限报警@" Type="BOOL" InitValue="FALSE" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="AM" OtherName="" Desc="@测量值报警信息@" Type="WORD" InitValue="0" Soe="0" Property="4">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="DK" OtherName="" Desc="@用户不可写——本周期微分计算值@" Type="REAL" InitValue="0" Soe="0" Property="4">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="DD" OtherName="" Desc="@用户不可写——第一次进入死区标志@" Type="BYTE" InitValue="0" Soe="0" Property="8192">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="UK" OtherName="" Desc="@用户不可写——控制输出(无输出补偿)@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="RALDVDB" OtherName="" Desc="@用户不可写——计算死区范围@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="DALLIM" OtherName="" Desc="@用户不可写——偏差报警限@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="OUTW" OtherName="" Desc="@用户不可写——位置式中间输出值@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="OUTZ" OtherName="" Desc="@用户不可写——增量式中间输出值@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="DU" OtherName="" Desc="@用户不可写——输出增量值(无输出补偿)@" Type="REAL" InitValue="0" Soe="0" Property="4">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="EK" OtherName="" Desc="@用户不可写——本周期偏差值@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="SV1" OtherName="" Desc="@用户不可写——计算积分分离值@" Type="REAL" InitValue="1" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="DA" OtherName="" Desc="@用户不可写——偏差报警状态:1-超差,0-正常@" Type="BOOL" InitValue="FALSE" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="OVE" OtherName="" Desc="@用户不可写——自动或串级状态下输出值到达上限或下限@" Type="BYTE" InitValue="0" Soe="0" Property="8192">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="D1" OtherName="" Desc="@用户不可写——上周期微分计算值@" Type="REAL" InitValue="0" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="U1" OtherName="" Desc="@用户不可写——上一周期的位置输出@" Type="REAL" InitValue="0" Soe="0" Property="8260">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="I1" OtherName="" Desc="@用户不可写——上一周期的增量输出@" Type="REAL" InitValue="0" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="preRM" OtherName="" Desc="@用户不可写——前运行方式@" Type="UINT" InitValue="0" Soe="0" Property="8192">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="nowRM" OtherName="" Desc="@用户不可写——目前运行方式@" Type="UINT" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="EK_1" OtherName="" Desc="@用户不可写——上一周期的偏差值@" Type="REAL" InitValue="0" Soe="0" Property="8192">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="EK_2" OtherName="" Desc="@用户不可写——上两个周期的偏差值@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="lastukout" OtherName="" Desc="@用户不可写——上周期位置式计算值@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="si" OtherName="" Desc="@用户不可写——积分分离标志@" Type="UINT" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="cycletime" OtherName="" Desc="@用户不可写——计算周期 500ms@" Type="REAL" InitValue="0.5" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="dudd" OtherName="" Desc="@用户不可写——微分分量的增量@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="lastduout" OtherName="" Desc="@用户不可写——上周期增量式计算值@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="DeadInterval" OtherName="" Desc="@用户不可写——死区范围@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="DevalmLimit" OtherName="" Desc="@用户不可写——偏差报警限@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="sp1" OtherName="" Desc="@用户不可写——设定值@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="ukout" OtherName="" Desc="@用户不可写——控制输出(有输出补偿)@" Type="REAL" InitValue="0" Soe="0" Property="8192">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="duout" OtherName="" Desc="@用户不可写——输出增量值(输出补偿)@" Type="REAL" InitValue="0" Soe="0" Property="8192">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="DT1" OtherName="" Desc="@用户不可写——比例带@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="almerror" OtherName="" Desc="@用户不可写——中间计算偏差值@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="mu1" OtherName="" Desc="@用户不可写——中间输出上限@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="md1" OtherName="" Desc="@用户不可写——中间输出下限@" Type="REAL" InitValue="0" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="CSRL" OtherName="" Desc="@用户不可写——副调节器的输出到达上限或下限的状态@" Type="BOOL" InitValue="FALSE" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="SPCAL" OtherName="" Desc="@用户不可写——设定值@" Type="REAL" InitValue="0" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="RALDB" OtherName="" Desc="@用户不可写——计算积分分离值@" Type="REAL" InitValue="1" Soe="0" Property="0">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="HHIND" OtherName="" Desc="@用户不可写——高高限报警@" Type="BOOL" InitValue="FALSE" Soe="0" Property="64">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="AHIND" OtherName="" Desc="@高限报警@" Type="BOOL" InitValue="FALSE" Soe="0" Property="64">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="ALIND" OtherName="" Desc="@低限报警@" Type="BOOL" InitValue="FALSE" Soe="0" Property="64">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="LLIND" OtherName="" Desc="@低低限报警@" Type="BOOL" InitValue="FALSE" Soe="0" Property="64">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="COMP" OtherName="" Desc="@用户不可写——过程输入值-输入补偿(仅对副调节器有效)@" Type="REAL" InitValue="0" Soe="0" Property="4">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="EVENFAULT" OtherName="" Desc="@用户不可写@" Type="BYTE" InitValue="0" Soe="0" Property="4">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="RealOutRat" OtherName="" Desc="@用户不可写——实际参与运算的单步输出限值@" Type="REAL" InitValue="100" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="RealGiveRat" OtherName="" Desc="@用户不可写——实际参与运算的给定值变化率,百分比(%/IEC周期)@" Type="REAL" InitValue="10" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="RALALMDB" OtherName="" Desc="@用户不可写@" Type="REAL" InitValue="0" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="SATDB" OtherName="" Desc="@饱和区间(OUTU\OUTL的百分比)@" Type="REAL" InitValue="0" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="RTYP" OtherName="" Desc="@爬坡方式，0=时间方式，1=速率方式@" Type="BOOL" InitValue="FALSE" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="RRAT" OtherName="" Desc="@用户不可写——爬坡实际速率，单位：工程量/min@" Type="REAL" InitValue="0" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="RTIME" OtherName="" Desc="@用户不可写——爬坡完成倒计时，单位：min@" Type="REAL" InitValue="0" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="OCTYP" OtherName="" Desc="@输出补偿方式，0=加法，1=乘法@" Type="BYTE" InitValue="0" Soe="0" Property="4132">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="CTRBP" OtherName="" Desc="@控制旁路，0=投用，1=旁路@" Type="BOOL" InitValue="FALSE" Soe="0" Property="8262">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="lastOUT" OtherName="" Desc="@用户不可写——上一个周期的输出值@" Type="REAL" InitValue="0" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="RCMDFlag" OtherName="" Desc="@用户不可写——爬坡标记@" Type="BOOL" InitValue="FALSE" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="preRTIMESP" OtherName="" Desc="@用户不可写——上周期设定爬坡时间@" Type="REAL" InitValue="0" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="preRRATSP" OtherName="" Desc="@用户不可写——上周期设定爬坡速率@" Type="REAL" InitValue="0" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="preRSPTV" OtherName="" Desc="@用户不可写——上周期设定目标值@" Type="REAL" InitValue="0" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="preRTYP" OtherName="" Desc="@用户不可写——上周期爬坡方式@" Type="BOOL" InitValue="FALSE" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="preSP" OtherName="" Desc="@用户不可写——上周期SP值@" Type="REAL" InitValue="0" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="preSP1" OtherName="" Desc="@用户不可写——上周期SP1值@" Type="REAL" InitValue="0" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="ROVEP" OtherName="" Desc="@输出超限时是否暂停爬坡，0=不暂停，1=暂停@" Type="BOOL" InitValue="FALSE" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="SPU" OtherName="" Desc="@SP上限值@" Type="REAL" InitValue="100" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="SPL" OtherName="" Desc="@SP下限值@" Type="REAL" InitValue="0" Soe="0" Property="100">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="MOLSW" OtherName="" Desc="@手动输出是否限幅 0-不限幅，1-限幅@" Type="BOOL" InitValue="TRUE" Soe="0" Property="96">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="EQN" OtherName="" Desc="@PID公式，0=标准型，1=微分先行，2=比例微分先行@" Type="BYTE" InitValue="0" Soe="0" Property="96">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="prePV" OtherName="" Desc="@用户不可写——上一个周期的输入值@" Type="REAL" InitValue="0" Soe="0" Property="64">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="preCTRBP" OtherName="" Desc="@用户不可写——上一个周期旁路状态@" Type="BOOL" InitValue="FALSE" Soe="0" Property="8256">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="LMBLS" OtherName="" Desc="@输出限幅无扰开关@" Type="BOOL" InitValue="FALSE" Soe="0" Property="96">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="MOFLAG" OtherName="" Desc="@手动切自动或串级时输出超限标记@" Type="BOOL" InitValue="FALSE" Soe="0" Property="64">
			<Data InOutType="TEMP"/>
		</VarDef>
		<VarDef Name="SIMU" OtherName="" Desc="@仿真模式@" Type="BOOL" InitValue="FALSE" Soe="0" Property="68">
			<Data InOutType="TEMP"/>
		</VarDef>
	</VarsData>
	<XmlVersion>1.0</XmlVersion>
</pou>

